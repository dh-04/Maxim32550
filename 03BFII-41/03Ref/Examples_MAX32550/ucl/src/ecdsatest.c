/*******************************************************************************
 * Copyright (C) 2017 Maxim Integrated Products, All Rights
 * Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL MAXIM INTEGRATED PRODUCTS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Maxim Integrated Products
 * shall not be used except as stated in the Maxim Integrated Products
 * Branding Policy.
 *
 * The mere transfer of this software does not imply any licenses
 * of trade secrets, proprietary technology, copyrights, patents,
 * trademarks, maskwork rights, or any other form of intellectual
 * property whatsoever. Maxim Integrated Products retains all ownership rights.
 *
 *     Module Name: ECC test application
 *     Description: performs ECC/ECDSA computations
 *        Filename: ecdsatest.c
 *          Author: LSL
 *        Compiler: gcc
 *
 *******************************************************************************
 */


#define FULLTEST
#ifndef _TESTCRYPTO_H
#define _TESTCRYPTO_H

#endif // _TESTCRYPTO_H

#include <ucl_testing_config.h>


#include <ucl/ecdsa_generic_api.h>
#include <ucl/bignum_ecdsa_generic_api.h>
#include <ucl/ucl_retdefs.h>
#include <ucl/ucl_types.h>
#include <ucl/ucl_config.h>
#include <ucl/ucl_defs.h>
#include <ucl/ucl_sys.h>
#include <ucl/ucl_data_conv.h>
#include <ucl/ucl_stack.h>
#include <ucl/ucl_ecc_keygen.h>
#include <ucl/ucl_sha1.h>
#include <ucl/ucl_sha224.h>
#include <ucl/ucl_sha256.h>
#include <ucl/ucl_sia256.h>
#include <ucl/ucl_sha384.h>
#include <ucl/ucl_sha512.h>
#include <ucl/ucl_sm3.h>
#include <ucl/ucl_rng.h>
#include <ucl/ucl_aes.h>

#include <string.h>

#ifdef NIST_CURVES
extern ucl_type_curve secp128r1;
extern ucl_type_curve secp160r1;
extern ucl_type_curve secp192r1;
extern ucl_type_curve secp224r1;
extern ucl_type_curve secp256r1;
extern ucl_type_curve secp256k1;
extern ucl_type_curve bp256r1;
extern ucl_type_curve bp384r1;
extern ucl_type_curve secp384r1;
extern ucl_type_curve secp521r1;
extern ucl_type_curve bp512r1;
#endif

#ifdef SM2P256
extern ucl_type_curve sm2fp256;
#endif
#ifdef SM2P192
extern ucl_type_curve sm2fp192;
#endif

// number of iterations of each test
#define LOOP 10

#define P160
#define P192
#define P224
#define P384

//draft-shen-sm2-ecdsa-01 test vectors section C.2
int test_sm2_encryption_decryption(int maxloop)
{
  u8 crypto[1000];
  u8 output[1000];
  u8 messageKAT[]={0x65,0x6E,0x63,0x72,0x79,0x70,0x74,0x69,0x6F,0x6E,0x20,0x73,0x74,0x61,0x6E,0x64,0x61,0x72,0x64};
  //private key dB
  u8 dBKAT[SM2FP256_BYTESIZE]={0x16,0x49,0xAB,0x77,0xA0,0x06,0x37,0xBD,0x5E,0x2E,0xFE,0x28,0x3F,0xBF,0x35,0x35,0x34,0xAA,0x7F,0x7C,0xB8,0x94,0x63,0xF2,0x08,0xDD,0xBC,0x29,0x20,0xBB,0x0D,0xA0};
  //x-coordinate xB:
  u8 xBKAT[SM2FP256_BYTESIZE]={0x43,0x5B,0x39,0xCC,0xA8,0xF3,0xB5,0x08,0xC1,0x48,0x8A,0xFC,0x67,0xBE,0x49,0x1A,0x0F,0x7B,0xA0,0x7E,0x58,0x1A,0x0E,0x48,0x49,0xA5,0xCF,0x70,0x62,0x8A,0x7E,0x0A};
  //y-coordinate yB:
  u8 yBKAT[SM2FP256_BYTESIZE]={0x75,0xDD,0xBA,0x78,0xF1,0x5F,0xEE,0xCB,0x4C,0x78,0x95,0xE2,0xC1,0xCD,0xF5,0xFE,0x01,0xDE,0xBB,0x2C,0xDB,0xAD,0xF4,0x53,0x99,0xCC,0xF7,0x7B,0xBA,0x07,0x6A,0x42};

  int klenKAT=152;
  int klen;
  u8 message[100];
  ucl_type_ecc_u8_affine_point pB;
  u8 xB[SM2FP256_BYTESIZE];
  u8 yB[SM2FP256_BYTESIZE];
  u8 dB[SM2FP256_BYTESIZE];
  int resu;
  int i,j,msgmax;
  u8 rnd;
  pB.x=xBKAT;
  pB.y=yBKAT;
  PRINTF("KAT\n");
  PRINTF("plain:");
  for(i=0;i<klenKAT/8;i++)
    PRINTF("%02x",messageKAT[i]);
  PRINTF("\n");
  resu=ucl_sm2_encryption_curve(crypto,pB,messageKAT,klenKAT,&sm2fp256);
  if(UCL_OK!=resu)
    {
      PRINTF("ERROR %d\n",resu);
      //      return(resu);
    }
  PRINTF("cryptotext:");
  for(i=0;i<klenKAT/8;i++)
    PRINTF("%02x",crypto[i]);
  PRINTF("\n");
  resu=ucl_sm2_decryption_curve(output,dBKAT,pB,crypto,klenKAT,&sm2fp256);
  if(UCL_OK!=resu)
    {
      PRINTF("ERROR %d\n",resu);
      return(resu);
    }
  PRINTF("plain:");
  for(i=0;i<klenKAT/8;i++)
    PRINTF("%02x",output[i]);
  PRINTF("\n");
  if(memcmp(output,messageKAT,klenKAT/8)==0)
    {
    PRINTF("DECRYPTION OK\n");
    }
  else
    {
      PRINTF("ERROR DECRYPTION\n");
      return(UCL_ERROR);
    }
  msgmax=5;
  //sm2 encryption-then-decryption check with random sm2fp256 keys, random messages, random messages lengths
  PRINTF("SM2 ENC-DEC %d.%d\n",maxloop,msgmax);
  for(i=0;i<maxloop;i++)
    {
      pB.x=xB;
      pB.y=yB;
      //generating the key
      resu=ucl_ecc_keygeneration_sm2fp256(pB,dB);
      if(resu!=UCL_OK)
	{
	  PRINTF("ERROR keygen %d\n",resu);
	  return(resu);
	}
      for(j=0;j<msgmax;j++)
	{
	  //generating the message
	  ucl_rng_read(&rnd,1,UCL_RAND_DEFAULT);
	  //random message length,in bits
	  klen=((rnd % 99)+1)*8;
	  //random message
	  ucl_rng_read(message,klen,UCL_RAND_DEFAULT);
	  //encryption result stored in crypto
	  ucl_sm2_encryption_curve(crypto,pB,message,klen,&sm2fp256);
	  if(UCL_OK!=resu)
	    {
	      PRINTF("ERROR ENC %d %d\n",resu,i);
	      return(resu);
	    }
	  //decryption from crypto
	  resu=ucl_sm2_decryption_curve(output,dB,pB,crypto,klen,&sm2fp256);
	  if(UCL_OK!=resu)
	    {
	      PRINTF("ERROR DEC %d %d\n",resu,i);
	      return(resu);
	    }
	  //compared with initial message
	  if(memcmp(output,message,klen/8)!=0)
	    {
	      PRINTF("ERROR %d\n",i);
	      return(UCL_ERROR);
	    }
	}
    }
  PRINTF("OK\n");
  return(UCL_OK);
}

#ifdef NIST_CURVES

int test_ecdsa_curves(void)
{
  //P160R1
   //GEC2 sample vector -sha1
  u8 d3_p160r1[]={0xAA,0x37,0x4F,0xFC,0x3C,0xE1,0x44,0xE6,0xB0,0x73,0x30,0x79,0x72,0xCB,0x6D,0x57,0xB2,0xA4,0xE9,0x82};
  u8 xq3_p160r1[]={0x51,0xB4,0x49,0x6F,0xEC,0xC4,0x06,0xED,0x0E,0x75,0xA2,0x4A,0x3C,0x03,0x20,0x62,0x51,0x41,0x9D,0xC0};
  u8 yq3_p160r1[]={0xC2,0x8D,0xCB,0x4B,0x73,0xA5,0x14,0xB4,0x68,0xD7,0x93,0x89,0x4F,0x38,0x1C,0xCC,0x17,0x56,0xAA,0x6C};
  u8 msg3_p160r1[]={'a','b','c'};
  u8 r3_p160r1[]={0xCE,0x28,0x73,0xE5,0xBE,0x44,0x95,0x63,0x39,0x1F,0xEB,0x47,0xDD,0xCB,0xA2,0xDC,0x16,0x37,0x91,0x91};
  u8 s3_p160r1[]={0x34,0x80,0xEC,0x13,0x71,0xA0,0x91,0xA4,0x64,0xB3,0x1C,0xE4,0x7D,0xF0,0xCB,0x8A,0xA2,0xD9,0x8B,0x54};

  u8 d3_p192r1[]={0x1a,0x8d,0x59,0x8f,0xc1,0x5b,0xf0,0xfd,0x89,0x03,0x0b,0x5c,0xb1,0x11,0x1a,0xeb,0x92,0xae,0x8b,0xaf,0x5e,0xa4,0x75,0xfb};
 u8 xq3_p192r1[]={0x62,0xB1,0x2D,0x60,0x69,0x0C,0xDC,0xF3,0x30,0xBA,0xBA,0xB6,0xE6,0x97,0x63,0xB4,0x71,0xF9,0x94,0xDD,0x70,0x2D,0x16,0xA5};
 u8 yq3_p192r1[]={0x63,0xBF,0x5E,0xC0,0x80,0x69,0x70,0x5F,0xFF,0xF6,0x5E,0x5C,0xA5,0xC0,0xD6,0x97,0x16,0xDF,0xCB,0x34,0x74,0x37,0x39,0x02};
  u8 msg3_p192r1[]={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17};
  u8 r3_p192r1[]={0x03,0xbe,0x83,0xbb,0x6d,0xff,0x29,0x25,0x87,0xa9,0x4d,0x13,0x8a,0x8e,0x1d,0x0e,0x6f,0x57,0xc3,0x78,0x69,0x68,0xe4,0xa3};
  u8 s3_p192r1[]={0xa9,0x47,0x0f,0xf0,0xda,0x47,0x7c,0xe6,0x7f,0x44,0x54,0xb1,0xb1,0x28,0x8d,0x04,0x79,0x90,0x6c,0xb6,0xdc,0x04,0x84,0x0d};


  //P224R1
  //RFC5114 test vector

  u8 d4_p224r1[]={0xB5,0x58,0xEB,0x6C,0x28,0x8D,0xA7,0x07,0xBB,0xB4,0xF8,0xFB,0xAE,0x2A,0xB9,0xE9,0xCB,0x62,0xE3,0xBC,0x5C,0x75,0x73,0xE2,0x2E,0x26,0xD3,0x7F};
  u8 xq4_p224r1[]={0x49,0xDF,0xEF,0x30,0x9F,0x81,0x48,0x8C,0x30,0x4C,0xFF,0x5A,0xB3,0xEE,0x5A,0x21,0x54,0x36,0x7D,0xC7,0x83,0x31,0x50,0xE0,0xA5,0x1F,0x3E,0xEB};
  u8 yq4_p224r1[]={0x4F,0x2B,0x5E,0xE4,0x57,0x62,0xC4,0xF6,0x54,0xC1,0xA0,0xC6,0x7F,0x54,0xCF,0x88,0xB0,0x16,0xB5,0x1B,0xCE,0x3D,0x7C,0x22,0x8D,0x57,0xAD,0xB4};

  //NIST ECDSAVS test vector -sha1
 u8 msg3_p224r1[] = {0x86,0x77,0x8d,0xbb,0x4a,0x06,0x8a,0x01,0x04,0x7a,0x8d,0x24,0x5d,0x63,0x2f,0x63,0x6c,0x11,0xd2,0xad,0x35,0x07,0x40,0xb3,0x6f,0xad,0x90,0x42,0x8b,0x45,0x4a,0xd0,0xf1,0x20,0xcb,0x55,0x8d,0x12,0xea,0x5c,0x8a,0x23,0xdb,0x59,0x5d,0x87,0x54,0x3d,0x06,0xd1,0xef,0x48,0x92,0x63,0xd0,0x1e,0xe5,0x29,0x87,0x1e,0xb6,0x87,0x37,0xef,0xdb,0x8f,0xf8,0x5b,0xc7,0x78,0x7b,0x61,0x51,0x4b,0xed,0x85,0xb7,0xe0,0x1d,0x6b,0xe2,0x09,0xe0,0xa4,0xeb,0x0d,0xb5,0xc8,0xdf,0x58,0xa5,0xc5,0xbf,0x70,0x6d,0x76,0xcb,0x2b,0xdf,0x78,0x00,0x20,0x86,0x39,0xe0,0x5b,0x89,0x51,0x71,0x55,0xd1,0x16,0x88,0x23,0x6e,0x6a,0x47,0xed,0x37,0xd8,0xe5,0xa2,0xb1,0xe0,0xad,0xea,0x33,0x8e};
  //public key
  u8 xq3_p224r1[]={0xad,0x5b,0xda,0x09,0xd3,0x19,0xa7,0x17,0xc1,0x72,0x1a,0xcd,0x66,0x88,0xd1,0x70,0x20,0xb3,0x1b,0x47,0xee,0xf1,0xed,0xea,0x57,0xce,0xef,0xfc};
  u8 yq3_p224r1[]={0xc8,0xce,0x98,0xe1,0x81,0x77,0x0a,0x7c,0x94,0x18,0xc7,0x3c,0x63,0xd0,0x14,0x94,0xb8,0xb8,0x0a,0x41,0x09,0x8c,0x5e,0xa5,0x06,0x92,0xc9,0x84};
  //signature for message above
  u8 r3_p224r1[]={0xde,0x55,0x58,0xc2,0x57,0xab,0x41,0x34,0xe5,0x2c,0x19,0xd8,0xdb,0x3b,0x22,0x4a,0x18,0x99,0xcb,0xd0,0x8c,0xc5,0x08,0xce,0x87,0x21,0xd5,0xe9};
  u8 s3_p224r1[]={0x74,0x5d,0xb7,0xaf,0x5a,0x47,0x7e,0x50,0x46,0x70,0x5c,0x0a,0x5e,0xff,0x1f,0x52,0xcb,0x94,0xa7,0x9d,0x48,0x1f,0x0c,0x5a,0x5e,0x10,0x8e,0xcd};


  //P256R1
  //RFC4754 test vector -sha256
  //secret key
  u8 d3_p256r1[]={0xDC,0x51,0xD3,0x86,0x6A,0x15,0xBA,0xCD,0xE3,0x3D,0x96,0xF9,0x92,0xFC,0xA9,0x9D,0xA7,0xE6,0xEF,0x09,0x34,0xE7,0x09,0x75,0x59,0xC2,0x7F,0x16,0x14,0xC8,0x8A,0x7F};
  //message
  u8 msg3_p256r1[]={'a','b','c'};
  //public key
  u8 xq3_p256r1[]={0x24,0x42,0xA5,0xCC,0x0E,0xCD,0x01,0x5F,0xA3,0xCA,0x31,0xDC,0x8E,0x2B,0xBC,0x70,0xBF,0x42,0xD6,0x0C,0xBC,0xA2,0x00,0x85,0xE0,0x82,0x2C,0xB0,0x42,0x35,0xE9,0x70};
  u8 yq3_p256r1[]={0x6F,0xC9,0x8B,0xD7,0xE5,0x02,0x11,0xA4,0xA2,0x71,0x02,0xFA,0x35,0x49,0xDF,0x79,0xEB,0xCB,0x4B,0xF2,0x46,0xB8,0x09,0x45,0xCD,0xDF,0xE7,0xD5,0x09,0xBB,0xFD,0x7D};
  //signature for the message above
  u8 r3_p256r1[]={0xCB,0x28,0xE0,0x99,0x9B,0x9C,0x77,0x15,0xFD,0x0A,0x80,0xD8,0xE4,0x7A,0x77,0x07,0x97,0x16,0xCB,0xBF,0x91,0x7D,0xD7,0x2E,0x97,0x56,0x6E,0xA1,0xC0,0x66,0x95,0x7C};
  u8 s3_p256r1[]={0x86,0xFA,0x3B,0xB4,0xE2,0x6C,0xAD,0x5B,0xF9,0x0B,0x7F,0x81,0x89,0x92,0x56,0xCE,0x75,0x94,0xBB,0x1E,0xA0,0xC8,0x92,0x12,0x74,0x8B,0xFF,0x3B,0x3D,0x5B,0x03,0x15};

  //P256K1
  /*private key: D30519BCAE8D180DBFCC94FE0B8383DC310185B0BE97B4365083EBCECCD75759  
2. public key x-coordinate: 3AF1E1EFA4D1E1AD5CB9E3967E98E901DAFCD37C44CF0BFB6C216997F5EE51DF  
3. public key y-coordinate: E4ACAC3E6F139E0C7DB2BD736824F51392BDA176965A1C59EB9C3C5FF9E85D7A  
4. hash: 3F891FDA3704F0368DAB65FA81EBE616F4AA2A0854995DA4DC0B59D2CADBD64F  
5. secure random integer k: CF554F5F4224223D52DC9CA784478FAC3C1A0D0419FDEEF27849A81846C71BA3  
6. r signature: A5C7B7756D34D8AAF6AA68F0B71644F0BEF90D8BFD126CE951B6060498345089  
7. s signature: BC9644F1625AF13841E589FD00653AE8C763309184EA0DE481E8F06709E5D1CB*/

  u8 xq3_p256k1[]={0x3A,0xF1,0xE1,0xEF,0xA4,0xD1,0xE1,0xAD,0x5C,0xB9,0xE3,0x96,0x7E,0x98,0xE9,0x01,0xDA,0xFC,0xD3,0x7C,0x44,0xCF,0x0B,0xFB,0x6C,0x21,0x69,0x97,0xF5,0xEE,0x51,0xDF};
  u8 yq3_p256k1[]={0xE4,0xAC,0xAC,0x3E,0x6F,0x13,0x9E,0x0C,0x7D,0xB2,0xBD,0x73,0x68,0x24,0xF5,0x13,0x92,0xBD,0xA1,0x76,0x96,0x5A,0x1C,0x59,0xEB,0x9C,0x3C,0x5F,0xF9,0xE8,0x5D,0x7A};
  u8 r3_p256k1[]={0xA5,0xC7,0xB7,0x75,0x6D,0x34,0xD8,0xAA,0xF6,0xAA,0x68,0xF0,0xB7,0x16,0x44,0xF0,0xBE,0xF9,0x0D,0x8B,0xFD,0x12,0x6C,0xE9,0x51,0xB6,0x06,0x04,0x98,0x34,0x50,0x89};  
  u8 s3_p256k1[]={0xBC,0x96,0x44,0xF1,0x62,0x5A,0xF1,0x38,0x41,0xE5,0x89,0xFD,0x00,0x65,0x3A,0xE8,0xC7,0x63,0x30,0x91,0x84,0xEA,0x0D,0xE4,0x81,0xE8,0xF0,0x67,0x09,0xE5,0xD1,0xCB};
  u8 msg3_p256k1[]={0x3F,0x89,0x1F,0xDA,0x37,0x04,0xF0,0x36,0x8D,0xAB,0x65,0xFA,0x81,0xEB,0xE6,0x16,0xF4,0xAA,0x2A,0x08,0x54,0x99,0x5D,0xA4,0xDC,0x0B,0x59,0xD2,0xCA,0xDB,0xD6,0x4F};
  u8 d3_p256k1[]={0xD3,0x05,0x19,0xBC,0xAE,0x8D,0x18,0x0D,0xBF,0xCC,0x94,0xFE,0x0B,0x83,0x83,0xDC,0x31,0x01,0x85,0xB0,0xBE,0x97,0xB4,0x36,0x50,0x83,0xEB,0xCE,0xCC,0xD7,0x57,0x59};

  //P384R1
  //RFC4754 test vector -sha384
  //secret key
  //d_secret
  u8 d3_p384r1[] = {0x0B,0xEB,0x64,0x66,0x34,0xBA,0x87,0x73,0x5D,0x77,0xAE,0x48,0x09,0xA0,0xEB,0xEA,0x86,0x55,0x35,0xDE,0x4C,0x1E,0x1D,0xCB,0x69,0x2E,0x84,0x70,0x8E,0x81,0xA5,0xAF,0x62,0xE5,0x28,0xC3,0x8B,0x2A,0x81,0xB3,0x53,0x09,0x66,0x8D,0x73,0x52,0x4D,0x9F};
  //message
  u8 msg3_p384r1[]={'a','b','c'};
  //public key
  u8 xq3_p384r1[]={0x96,0x28,0x1B,0xF8,0xDD,0x5E,0x05,0x25,0xCA,0x04,0x9C,0x04,0x8D,0x34,0x5D,0x30,0x82,0x96,0x8D,0x10,0xFE,0xDF,0x5C,0x5A,0xCA,0x0C,0x64,0xE6,0x46,0x5A,0x97,0xEA,0x5C,0xE1,0x0C,0x9D,0xFE,0xC2,0x17,0x97,0x41,0x57,0x10,0x72,0x1F,0x43,0x79,0x22};
  u8 yq3_p384r1[]={0x44,0x76,0x88,0xBA,0x94,0x70,0x8E,0xB6,0xE2,0xE4,0xD5,0x9F,0x6A,0xB6,0xD7,0xED,0xFF,0x93,0x01,0xD2,0x49,0xFE,0x49,0xC3,0x30,0x96,0x65,0x5F,0x5D,0x50,0x2F,0xAD,0x3D,0x38,0x3B,0x91,0xC5,0xE7,0xED,0xAA,0x2B,0x71,0x4C,0xC9,0x9D,0x57,0x43,0xCA};
  //signature for the message above
  u8 r3_p384r1[]={0xFB,0x01,0x7B,0x91,0x4E,0x29,0x14,0x94,0x32,0xD8,0xBA,0xC2,0x9A,0x51,0x46,0x40,0xB4,0x6F,0x53,0xDD,0xAB,0x2C,0x69,0x94,0x80,0x84,0xE2,0x93,0x0F,0x1C,0x8F,0x7E,0x08,0xE0,0x7C,0x9C,0x63,0xF2,0xD2,0x1A,0x07,0xDC,0xB5,0x6A,0x6A,0xF5,0x6E,0xB3};
  u8 s3_p384r1[]={0xB2,0x63,0xA1,0x30,0x5E,0x05,0x7F,0x98,0x4D,0x38,0x72,0x6A,0x1B,0x46,0x87,0x41,0x09,0xF4,0x17,0xBC,0xA1,0x12,0x67,0x4C,0x52,0x82,0x62,0xA4,0x0A,0x62,0x9A,0xF1,0xCB,0xB9,0xF5,0x16,0xCE,0x0F,0xA7,0xD2,0xFF,0x63,0x08,0x63,0xA0,0x0E,0x8B,0x9F};

  //P521R1
   //RFC4754 test vector -sha512
   //secret key
   u8 d3_p521r1[] = {0x00,0x65,0xFD,0xA3,0x40,0x94,0x51,0xDC,0xAB,0x0A,0x0E,0xAD,0x45,0x49,0x51,0x12,0xA3,0xD8,0x13,0xC1,0x7B,0xFD,0x34,0xBD,0xF8,0xC1,0x20,0x9D,0x7D,0xF5,0x84,0x91,0x20,0x59,0x77,0x79,0x06,0x0A,0x7F,0xF9,0xD7,0x04,0xAD,0xF7,0x8B,0x57,0x0F,0xFA,0xD6,0xF0,0x62,0xE9,0x5C,0x7E,0x0C,0x5D,0x54,0x81,0xC5,0xB1,0x53,0xB4,0x8B,0x37,0x5F,0xA1};
   //message
   u8 msg3_p521r1[]={'a','b','c'};
   //public key
 u8 xq3_p521r1[]={0x01,0x51,0x51,0x8F,0x1A,0xF0,0xF5,0x63,0x51,0x7E,0xDD,0x54,0x85,0x19,0x0D,0xF9,0x5A,0x4B,0xF5,0x7B,0x5C,0xBA,0x4C,0xF2,0xA9,0xA3,0xF6,0x47,0x47,0x25,0xA3,0x5F,0x7A,0xFE,0x0A,0x6D,0xDE,0xB8,0xBE,0xDB,0xCD,0x6A,0x19,0x7E,0x59,0x2D,0x40,0x18,0x89,0x01,0xCE,0xCD,0x65,0x06,0x99,0xC9,0xB5,0xE4,0x56,0xAE,0xA5,0xAD,0xD1,0x90,0x52,0xA8};
 u8 yq3_p521r1[]={0x00,0x6F,0x3B,0x14,0x2E,0xA1,0xBF,0xFF,0x7E,0x28,0x37,0xAD,0x44,0xC9,0xE4,0xFF,0x6D,0x2D,0x34,0xC7,0x31,0x84,0xBB,0xAD,0x90,0x02,0x6D,0xD5,0xE6,0xE8,0x53,0x17,0xD9,0xDF,0x45,0xCA,0xD7,0x80,0x3C,0x6C,0x20,0x03,0x5B,0x2F,0x3F,0xF6,0x3A,0xFF,0x4E,0x1B,0xA6,0x4D,0x1C,0x07,0x75,0x77,0xDA,0x3F,0x42,0x86,0xC5,0x8F,0x0A,0xEA,0xE6,0x43};
   //signature for the message above
 u8 r3_p521r1[]={0x01,0x54,0xFD,0x38,0x36,0xAF,0x92,0xD0,0xDC,0xA5,0x7D,0xD5,0x34,0x1D,0x30,0x53,0x98,0x85,0x34,0xFD,0xE8,0x31,0x8F,0xC6,0xAA,0xAA,0xB6,0x8E,0x2E,0x6F,0x43,0x39,0xB1,0x9F,0x2F,0x28,0x1A,0x7E,0x0B,0x22,0xC2,0x69,0xD9,0x3C,0xF8,0x79,0x4A,0x92,0x78,0x88,0x0E,0xD7,0xDB,0xB8,0xD9,0x36,0x2C,0xAE,0xAC,0xEE,0x54,0x43,0x20,0x55,0x22,0x51};
 u8 s3_p521r1[]={0x01,0x77,0x05,0xA7,0x03,0x02,0x90,0xD1,0xCE,0xB6,0x05,0xA9,0xA1,0xBB,0x03,0xFF,0x9C,0xDD,0x52,0x1E,0x87,0xA6,0x96,0xEC,0x92,0x6C,0x8C,0x10,0xC8,0x36,0x2D,0xF4,0x97,0x53,0x67,0x10,0x1F,0x67,0xD1,0xCF,0x9B,0xCC,0xBF,0x2F,0x3D,0x23,0x95,0x34,0xFA,0x50,0x9E,0x70,0xAA,0xC8,0x51,0xAE,0x01,0xAA,0xC6,0x8D,0x62,0xF8,0x66,0x47,0x26,0x60};

 //BP256R1
 //RFC6932 test vector
 u8 d3_bp256r1[] ={0x04,0x1E,0xB8,0xB1,0xE2,0xBC,0x68,0x1B,0xCE,0x8E,0x39,0x96,0x3B,0x2E,0x9F,0xC4,0x15,0xB0,0x52,0x83,0x31,0x3D,0xD1,0xA8,0xBC,0xC0,0x55,0xF1,0x1A,0xE4,0x96,0x99};
 u8 xq3_bp256r1[]={0x78,0x02,0x84,0x96,0xB5,0xEC,0xAA,0xB3,0xC8,0xB6,0xC1,0x2E,0x45,0xDB,0x1E,0x02,0xC9,0xE4,0xD2,0x6B,0x41,0x13,0xBC,0x4F,0x01,0x5F,0x60,0xC5,0xCC,0xC0,0xD2,0x06};
 u8 yq3_bp256r1[]={0xA2,0xAE,0x17,0x62,0xA3,0x83,0x1C,0x1D,0x20,0xF0,0x3F,0x8D,0x1E,0x3C,0x0C,0x39,0xAF,0xE6,0xF0,0x9B,0x4D,0x44,0xBB,0xE8,0x0C,0xD1,0x00,0x98,0x7B,0x05,0xF9,0x2B};
 //message
 u8 msg3_bp256r1[]={'a','b','c'};
u8 r3_bp256r1[]={0x56,0xd4,0xd0,0xd0,0xfa,0x96,0xa9,0x60,0x2b,0x1f,0x05,0xb9,0x06,0x34,0x1c,0x0a,0xfa,0xa2,0x1b,0xaa,0x5e,0xd6,0x8d,0xa7,0x1f,0x08,0xa1,0xcc,0x7b,0x2b,0xe7,0xd9};
u8 s3_bp256r1[]={0x40,0xa6,0xc8,0x3e,0xed,0x38,0x8e,0x26,0xdf,0xec,0xc5,0x90,0x63,0xed,0x7b,0x59,0xde,0xe1,0x43,0x5d,0x20,0x5a,0x93,0x4d,0x72,0x7f,0xed,0xfc,0x9f,0xa6,0x4f,0x35}; 
 //BP384R1
 //RFC 6932
 u8 d3_bp384r1[] = {0x01,0x4E,0xC0,0x75,0x5B,0x78,0x59,0x4B,0xA4,0x7F,0xB0,0xA5,0x6F,0x61,0x73,0x04,0x5B,0x43,0x31,0xE7,0x4B,0xA1,0xA6,0xF4,0x73,0x22,0xE7,0x0D,0x79,0xD8,0x28,0xD9,0x7E,0x09,0x58,0x84,0xCA,0x72,0xB7,0x3F,0xDA,0xBD,0x59,0x10,0xDF,0x0F,0xA7,0x6A};
 u8 xq3_bp384r1[] = {0x45,0xCB,0x26,0xE4,0x38,0x4D,0xAF,0x6F,0xB7,0x76,0x88,0x53,0x07,0xB9,0xA3,0x8B,0x7A,0xD1,0xB5,0xC6,0x92,0xE0,0xC3,0x2F,0x01,0x25,0x33,0x27,0x78,0xF3,0xB8,0xD3,0xF5,0x0C,0xA3,0x58,0x09,0x9B,0x30,0xDE,0xB5,0xEE,0x69,0xA9,0x5C,0x05,0x8B,0x4E};
 u8 yq3_bp384r1[] = {0x81,0x73,0xA1,0xC5,0x4A,0xFF,0xA7,0xE7,0x81,0xD0,0xE1,0xE1,0xD1,0x2C,0x0D,0xC2,0xB7,0x4F,0x4D,0xF5,0x8E,0x4A,0x4E,0x3A,0xF7,0x02,0x6C,0x5D,0x32,0xDC,0x53,0x0A,0x2C,0xD8,0x9C,0x85,0x9B,0xB4,0xB4,0xB7,0x68,0x49,0x7F,0x49,0xAB,0x8C,0xC8,0x59};
 //message
 u8 msg3_bp384r1[]={'a','b','c'};
u8 r3_bp384r1[]={0x12,0x45,0xdf,0xf5,0x15,0x1f,0xb1,0xed,0x4b,0x99,0xfd,0xef,0xe2,0x48,0x9e,0x16,0xcf,0x70,0x5a,0x2d,0x7e,0xa7,0x7b,0xa8,0xea,0x88,0x2f,0x17,0x8f,0x48,0x9f,0x3d,0x2c,0xa2,0xf4,0xc5,0xc5,0xf5,0xc9,0xde,0x5e,0xd0,0xd5,0x69,0x7e,0x93,0xe8,0xa8};
u8 s3_bp384r1[]={0x0c,0xf4,0xe5,0x7a,0xe9,0x20,0xbd,0x4f,0x49,0xcb,0xdc,0xf8,0xf0,0xa5,0x33,0xa9,0x47,0x25,0xf5,0x3e,0x26,0x46,0xde,0x45,0xcd,0x91,0x83,0x96,0xe8,0xd3,0xc8,0x9b,0xa9,0x9f,0x39,0xf1,0xdf,0x96,0x5b,0x07,0xd8,0x41,0x0c,0x67,0x91,0xa8,0x38,0xa6};
 
 //BP512R1
 //RFC 6932
 u8 d3_bp512r1[]={0x63,0x6B,0x6B,0xE0,0x48,0x2A,0x6C,0x1C,0x41,0xAA,0x7A,0xE7,0xB2,0x45,0xE9,0x83,0x39,0x2D,0xB9,0x4C,0xEC,0xEA,0x26,0x60,0xA3,0x79,0xCF,0xE1,0x59,0x55,0x9E,0x35,0x75,0x81,0x82,0x53,0x91,0x17,0x5F,0xC1,0x95,0xD2,0x8B,0xAC,0x0C,0xF0,0x3A,0x78,0x41,0xA3,0x83,0xB9,0x5C,0x26,0x2B,0x98,0x37,0x82,0x87,0x4C,0xCE,0x6F,0xE3,0x33};
 u8 xq3_bp512r1[] ={0x05,0x62,0xE6,0x8B,0x9A,0xF7,0xCB,0xFD,0x55,0x65,0xC6,0xB1,0x68,0x83,0xB7,0x77,0xFF,0x11,0xC1,0x99,0x16,0x1E,0xCC,0x42,0x7A,0x39,0xD1,0x7E,0xC2,0x16,0x64,0x99,0x38,0x95,0x71,0xD6,0xA9,0x94,0x97,0x7C,0x56,0xAD,0x82,0x52,0x65,0x8B,0xA8,0xA1,0xB7,0x2A,0xE4,0x2F,0x4F,0xB7,0x53,0x21,0x51,0xAF,0xC3,0xEF,0x09,0x71,0xCC,0xDA};
 u8 yq3_bp512r1[] ={0xA7,0xCA,0x2D,0x81,0x91,0xE2,0x17,0x76,0xA8,0x98,0x60,0xAF,0xBC,0x1F,0x58,0x2F,0xAA,0x30,0x8D,0x55,0x1C,0x1D,0xC6,0x13,0x3A,0xF9,0xF9,0xC3,0xCA,0xD5,0x99,0x98,0xD7,0x00,0x79,0x54,0x81,0x40,0xB9,0x0B,0x1F,0x31,0x1A,0xFB,0x37,0x8A,0xA8,0x1F,0x51,0xB2,0x75,0xB2,0xBE,0x6B,0x7D,0xEE,0x97,0x8E,0xFC,0x73,0x43,0xEA,0x64,0x2E};
 //message
u8 msg3_bp512r1[]={'a','b','c'};
u8 r3_bp512r1[]={0x93,0x0b,0x87,0x41,0x6f,0x43,0x6c,0x5d,0xba,0x06,0xc1,0x63,0x15,0x3e,0x82,0x87,0x59,0xbd,0x4a,0x66,0xc3,0x34,0xe0,0x8d,0x2d,0x66,0x6f,0xe8,0x23,0xb0,0x83,0xad,0xec,0xd6,0xb6,0x15,0xf6,0xfb,0xf0,0xa8,0x50,0xc7,0x3f,0xe3,0xfa,0xbb,0xb2,0xdc,0x9d,0x1a,0xa4,0xc5,0xca,0x53,0x72,0x22,0xb3,0x48,0x2f,0xeb,0xad,0x4b,0xe1,0x34};
u8 s3_bp512r1[]={0x3e,0x2f,0xcf,0xa1,0x2d,0x1a,0x6e,0xd8,0x08,0x30,0x5b,0xea,0xce,0xd7,0xe7,0xa0,0xbb,0xf8,0x48,0x62,0x5a,0xca,0xfc,0x3b,0x8e,0x15,0x97,0xb4,0xc3,0x2e,0xf2,0x48,0x84,0x90,0x43,0x9b,0x20,0x80,0xe9,0xef,0x7b,0x7d,0xdb,0x22,0xad,0x41,0xbd,0x1e,0x58,0xdb,0xb8,0x4a,0xf1,0xe2,0x29,0xe4,0x16,0xc0,0xd9,0x1e,0x90,0x7a,0xf2,0xa4};
    
 u8 *msg3;
 u8 *d3;
 int msg3_len;
 int resu;
 int i,loop;
 int configuration;
 int hash,hash_start,hash_end;
 int curve;
 int err;

 ucl_type_ecc_u8_affine_point q3;
 ucl_type_ecdsa_signature signature;
 ucl_type_curve *curve_params;
 int (*hash_function_ptr)(u8*,u8*,u32);

 char curve_name[MAX_CURVE][20];
 char hash_name[MAX_HASH_FUNCTIONS][20];
 unsigned int hash_size[20];

 hash_size[UCL_SHA1]=UCL_SHA1_HASHSIZE;
 hash_size[UCL_SHA224]=UCL_SHA224_HASHSIZE;
 hash_size[UCL_SHA256]=UCL_SHA256_HASHSIZE;
 hash_size[UCL_SHA384]=UCL_SHA384_HASHSIZE;
 hash_size[UCL_SHA512]=UCL_SHA512_HASHSIZE;

 sprintf(hash_name[UCL_SHA1],"sha1");
 sprintf(hash_name[UCL_SHA224],"sha224");
 sprintf(hash_name[UCL_SHA256],"sha256");
 sprintf(hash_name[UCL_SHA384],"sha384");
 sprintf(hash_name[UCL_SHA512],"sha512");
 
 sprintf(curve_name[SECP128R1],"p128r1");
 sprintf(curve_name[SECP160R1],"p160r1");
 sprintf(curve_name[SECP192R1],"p192r1");
 sprintf(curve_name[SECP224R1],"p224r1");
 sprintf(curve_name[SECP256R1],"p256r1");
 sprintf(curve_name[SECP256K1],"p256k1");
 sprintf(curve_name[SECP384R1],"p384r1");
 sprintf(curve_name[SECP521R1],"p521r1");
 sprintf(curve_name[BP256R1],"bp256r1");
 sprintf(curve_name[BP384R1],"bp384r1");
 sprintf(curve_name[BP512R1],"bp512r1");


#ifdef SM2P192
 sprintf(curve_name[SM2FP192],"sm2fp192");
#endif
#ifdef SM2P256
 sprintf(curve_name[SM2FP256],"sm2fp256");
#endif
 
  PRINTF("TEST ECDSA curves\n");
  for(curve=SECP256R1;curve<=SECP256K1;curve++)

    //not testing SM2 curves
    if(curve!=SM2VP256)
      if(curve!=SM2FP192)
	if(curve!=SM2FP256)
	  if(curve!=SECP128R1)
	  {
	    PRINTF("ECDSA-%s TEST START -----\n",curve_name[curve]);

	  //configure the parameters
	  msg3=msg3_p160r1;
	  d3=d3_p160r1;
	  curve_params=&secp160r1;
	  hash_function_ptr=(&ucl_sha1);
	  hash=UCL_SHA1;
	  msg3_len=sizeof(msg3_p160r1);
	  if(curve==SECP128R1)
	    {
	      signature.r=r3_p256r1;
	      signature.s=s3_p256r1;
	      q3.x=xq3_p256r1;
	      q3.y=yq3_p256r1;
	      curve_params=&secp128r1;
	      hash_function_ptr=(&ucl_sha1);
	      d3=d3_p256r1;
	      hash=UCL_SHA1;
	    }
	  if(curve==SECP160R1)
	    {
	      signature.r=r3_p160r1;
	      signature.s=s3_p160r1;
	      q3.x=xq3_p160r1;
	      q3.y=yq3_p160r1;
	      msg3=msg3_p160r1;
	      msg3_len=sizeof(msg3_p160r1);
	      curve_params=&secp160r1;
	      hash_function_ptr=(&ucl_sha1);
	      d3=d3_p160r1;
	      hash=UCL_SHA1;
	    }
	  if(curve==SECP192R1)
	    {
	      signature.r=r3_p192r1;
	      signature.s=s3_p192r1;
	      q3.x=xq3_p192r1;
	      q3.y=yq3_p192r1;
	      msg3=msg3_p192r1;
	      msg3_len=sizeof(msg3_p192r1);
	      curve_params=&secp192r1;
	      hash_function_ptr=(&ucl_sha1);
	      d3=d3_p192r1;
	      hash=UCL_SHA1;
	    }
	  if(curve==SECP224R1)
	    {
	      signature.r=r3_p224r1;
	      signature.s=s3_p224r1;
	      q3.x=xq3_p224r1;
	      q3.y=yq3_p224r1;
	      msg3=msg3_p224r1;
	      msg3_len=sizeof(msg3_p224r1);
	      curve_params=&secp224r1;
	      hash_function_ptr=(&ucl_sha1);
	      d3=d4_p224r1;
	      hash=UCL_SHA1;
	    }
	  if(curve==SECP256R1)
	    {
	      signature.r=r3_p256r1;
	      signature.s=s3_p256r1;
	      q3.x=xq3_p256r1;
	      q3.y=yq3_p256r1;
	      msg3=msg3_p256r1;
	      msg3_len=sizeof(msg3_p256r1);
	      curve_params=&secp256r1;
	      hash_function_ptr=(&ucl_sha256);
	      d3=d3_p256r1;
	      hash=UCL_SHA256;
	    }
	  if(curve==SECP256K1)
	    {
	      signature.r=r3_p256k1;
	      signature.s=s3_p256k1;
	      q3.x=xq3_p256k1;
	      q3.y=yq3_p256k1;
	      msg3=msg3_p256k1;
	      msg3_len=sizeof(msg3_p256k1);
	      curve_params=&secp256k1;
	      hash_function_ptr=(&ucl_sha256);
	      d3=d3_p256k1;
	      hash=UCL_SHA256;
	    }
	  if(curve==SECP384R1)
	    {
	      signature.r=r3_p384r1;
	      signature.s=s3_p384r1;
	      q3.x=xq3_p384r1;
	      q3.y=yq3_p384r1;
	      msg3=msg3_p384r1;
	      msg3_len=sizeof(msg3_p384r1);
	      curve_params=&secp384r1;
	      hash_function_ptr=(&ucl_sha384);
	      d3=d3_p384r1;
	      hash=UCL_SHA384;
	    }
	  
	  if(curve==SECP521R1)
	    {
	      signature.r=r3_p521r1;
	      signature.s=s3_p521r1;
	      q3.x=xq3_p521r1;
	      q3.y=yq3_p521r1;
	      msg3=msg3_p521r1;
	      msg3_len=sizeof(msg3_p521r1);
	      curve_params=&secp521r1;
	      hash_function_ptr=(&ucl_sha512);
	      d3=d3_p521r1;
	      hash=UCL_SHA512;
	    }
	  
	  if(curve==BP256R1)
	    {
	      signature.r=r3_bp256r1;
	      signature.s=s3_bp256r1;
	      q3.x=xq3_bp256r1;
	      q3.y=yq3_bp256r1;
	      msg3=msg3_bp256r1;
	      msg3_len=sizeof(msg3_bp256r1);
	      curve_params=&bp256r1;
	      hash_function_ptr=(&ucl_sha256);
	      d3=d3_bp256r1;
	      hash=UCL_SHA256;
	    }
	  if(curve==BP384R1)
	    {
	      signature.r=r3_bp384r1;
	      signature.s=s3_bp384r1;
	      q3.x=xq3_bp384r1;
	      q3.y=yq3_bp384r1;
	      msg3=msg3_bp384r1;
	      msg3_len=sizeof(msg3_bp384r1);
	      curve_params=&bp384r1;
	      hash_function_ptr=(&ucl_sha384);
	      d3=d3_bp384r1;
	      hash=UCL_SHA384;
	    }
	  if(curve==BP512R1)
	    {
	      signature.r=r3_bp512r1;
	      signature.s=s3_bp512r1;
	      q3.x=xq3_bp512r1;
	      q3.y=yq3_bp512r1;
	      msg3=msg3_bp512r1;
	      msg3_len=sizeof(msg3_bp512r1);
	      curve_params=&bp512r1;
	      hash_function_ptr=(&ucl_sha512);
	      d3=d3_bp512r1;
	      hash=UCL_SHA512;
	    }
	  
	  if(curve==SECP256K1)//for the secp256k1 KAT, the input is the message hash, not the message
	    configuration=(curve<<UCL_CURVE_SHIFT)^(UCL_HASH_INPUT<<UCL_INPUT_SHIFT)^(hash<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP<<UCL_PRECOMP_TRICK_SHIFT);
	  else
	    configuration=(curve<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(hash<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP<<UCL_PRECOMP_TRICK_SHIFT);
	  resu=ucl_ecdsa_verification(q3,signature,hash_function_ptr,msg3,msg3_len,curve_params,configuration);
	  if(resu==UCL_OK)
	    {
	      PRINTF("ECDSA-%s-%s SIGNATURE VERIFICATION TEST-1 OK\n",curve_name[curve],hash_name[hash]);
	    }
	  else
	    {
	      PRINTF("ECDSA-%s-%s SIGNATURE VERIFICATION TEST-1 NOK %d \n",curve_name[curve],hash_name[hash],resu);
	      return(UCL_ERROR);
	    }

	  hash_start=UCL_SHA1;
	  hash_end=UCL_SHA512;
	  for(hash=hash_start;hash<=hash_end;hash++)
	    {
	      if(UCL_SHA1==hash)
		hash_function_ptr=(&ucl_sha1);
	      if(UCL_SHA224==hash)
		hash_function_ptr=(&ucl_sha224);
	      if(UCL_SHA256==hash)
		hash_function_ptr=(&ucl_sha256);
	      if(UCL_SHA384==hash)
		hash_function_ptr=(&ucl_sha384);
	      if(UCL_SHA512==hash)
		hash_function_ptr=(&ucl_sha512);
	      //loop on sign+verify cycles, with RFC 4754 parameters fixed
	      //only the ECDSA random number is changing
	      loop=LOOP;
	      PRINTF("ECDSA COMPUTATION %s-%s SIGN, loop=%d ",curve_name[curve],hash_name[hash],loop);
	      configuration=(curve<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(hash<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP<<UCL_PRECOMP_TRICK_SHIFT);
	      for(i=0;i<loop;i++)
		{

		  err=ucl_ecdsa_signature(signature,d3,hash_function_ptr,msg3,msg3_len,curve_params,configuration);
		  if(UCL_OK!=err)
		    {
		      if(hash_size[hash]<curve_params->curve_bsize && UCL_INVALID_INPUT==err)
			{
			PRINTF("ERROR AS EXPECTED\n");
			}
		      else
			PRINTF("ERROR SIGN %d %s\n",err,curve_name[curve]);
		      break;
		    }
		}
	      PRINTF("ECDSA COMPUTATION %s-%s VERIFY, loop=%d\n",curve_name[curve],hash_name[hash],loop);
	      configuration=(curve<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(hash<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP<<UCL_PRECOMP_TRICK_SHIFT);
	      for(i=0;i<loop;i++)
		ucl_ecdsa_verification(q3,signature,hash_function_ptr,msg3,msg3_len,curve_params,configuration);
#ifdef VERBOSE
	      PRINTF("ECDSA COMPUTATION %s-%s SIGN+VERIFY, loop=%d ",curve_name[curve],hash_name[hash],loop);
#endif
	      //for p224r1, the KAT used for sign+verify is different from the verify KAT
	      if(curve==SECP224R1)
		{
		  q3.x=xq4_p224r1;
		  q3.y=yq4_p224r1;
		  d3=d4_p224r1;
		}
	      for(i=0;i<loop;i++)
		{
		  err=ucl_ecc_keygeneration_generic(q3,d3,curve_params);
		  if(UCL_OK!=err)
		    PRINTF("key generation ERROR\n");
		  //generating a new signature and verifying it with the direct routine (so using precomputation)
		  configuration=(curve<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(hash<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP<<UCL_PRECOMP_TRICK_SHIFT);


		  err=ucl_ecdsa_signature(signature,d3,hash_function_ptr,msg3,msg3_len,curve_params,configuration);
		  if(UCL_OK!=err)
		    {
		      if(hash_size[hash]<curve_params->curve_bsize && UCL_INVALID_INPUT==err)
			{
			PRINTF("ERROR AS EXPECTED\n");
			}
		      else
			PRINTF("ERROR SIGN %d %s\n",err,curve_name[curve]);
		      break;
		    }
		  resu=ucl_ecdsa_verification(q3,signature,hash_function_ptr,msg3,msg3_len,curve_params,configuration);
		  if(UCL_OK!=err)
		    {
		      if(hash_size[hash]<curve_params->curve_bsize && UCL_INVALID_INPUT==err)
			{
			PRINTF("ERROR AS EXPECTED\n");
			}
		      else
			{
			  PRINTF("ECDSA SIGNATURE TEST-LOOP %s-%s NOK %d \n",curve_name[curve],hash_name[hash],resu);
			  return(UCL_ERROR);
			}
		      break;
		    }
		}
	    }
	}
    return(UCL_OK);
}
#endif//NIST_CURVES

#ifdef SM2P256

void SM2Test(void)
{
  int iRet;
  u8 r[32], s[32], xA[32], yA[32], in[300], ida[32], entla[32];
  u8 a[32], b[32], p[32], xG[32], yG[32], n[32];
  u32 dInLen, dCfg;
  ucl_type_ecdsa_signature signature;
  ucl_type_ecc_u8_affine_point A;
  ucl_type_curve sm2vp256;
  DIGIT tmp_a[SM2FP256_WORDSIZE];
  DIGIT tmp_b[SM2FP256_WORDSIZE];
  DIGIT tmp_n[SM2FP256_WORDSIZE];
  DIGIT tmp_p[SM2FP256_WORDSIZE];
  DIGIT tmp_xg[SM2FP256_WORDSIZE];
  DIGIT tmp_yg[SM2FP256_WORDSIZE];
  DIGIT tmp_inv2[SM2FP256_WORDSIZE];

  dCfg=(SM2VP256<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(UCL_SM3<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP_TRICK<<UCL_PRECOMP_TRICK_SHIFT);

  dInLen = 0x4E;
  memset(in, 0x00, sizeof(in));
  memcpy(in, 
    "\x12\x62\x28\x00\x01\x12\x20\x00\x00\x01\x04\x00\x11\x40\x9F\x48"
    "\x3B\xF2\xCC\x71\xC5\x09\x37\x28\x31\x80\x61\xE3\xF7\x68\xEA\x7C"
    "\x17\x0F\x82\xDD\x8C\x4B\x97\x9F\xBD\x8C\x76\xA1\x29\xF9\x3F\xB5"
    "\x74\x6E\x96\xF5\xE4\x9B\x98\x7F\xFB\x52\x1E\x47\x3B\x25\xE1\xB0"
    "\x17\xC3\x0B\xE3\xFC\x63\x8B\xA1\x4D\x5F\xA4\xAA\xDC\x16",
    dInLen);
  memset(r, 0x00, sizeof(r));
  memcpy(r,
    "\xB1\xE1\xA0\x2E\xD6\x2D\x81\x12\x68\xC4\xA2\x12\x3C\xD8\xB2\x66"
    "\x90\xBC\xE1\x4B\xB7\xA0\x17\x13\xC0\x1C\x2D\x2F\xF2\x89\x2D\x15",
    0x20);
  memset(s, 0x00, sizeof(s));
  memcpy(s,
    "\x96\xA7\xD9\xD1\x31\xC7\x38\x13\xC3\xA3\xD6\xF8\x51\xDC\xDA\x91"
    "\x7E\x98\x69\x23\xF9\x8D\xD2\x44\x4A\xDC\x8E\xF0\xD0\xCE\x1E\x2A",
    0x20);
  memset(xA, 0x00, sizeof(xA));
  memcpy(xA,
    "\xE8\x10\x5E\x77\x86\x1F\xD2\xEB\x72\x7C\x84\xE3\x6D\x3D\x4A\x56"
    "\x66\xBD\x0A\xDC\xE8\x78\x1F\x01\x45\xD3\xD8\x2D\x72\xB9\x27\x48",
    0x20);
  memset(yA, 0x00, sizeof(yA));
  memcpy(yA,
    "\xE2\x2D\x54\x04\xC6\xC4\x1F\x3E\xC8\xB7\x90\xDE\x2F\x61\xCF\x29"
    "\xFA\xEC\xB1\x68\xC7\x9F\x5C\x86\x66\x76\x2D\x53\xCC\x26\xA4\x60",
    0x20);
  memset(ida, 0x00, sizeof(ida));
  memcpy(ida, "\x31\x32\x33\x34\x35\x36\x37\x38\x31\x32\x33\x34\x35\x36\x37\x38", 0x10);
  memset(entla, 0x00, sizeof(entla));
  memcpy(entla, "\x00\x80", 2);

  memset(p, 0x00, sizeof(p));
  memcpy(p, 
    "\xFF\xFF\xFF\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    "\xFF\xFF\xFF\xFF\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
    0x20);
  memset(a, 0x00, sizeof(a));
  memcpy(a, 
    "\xFF\xFF\xFF\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    "\xFF\xFF\xFF\xFF\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC",
    0x20);
  memset(b, 0x00, sizeof(b));
  memcpy(b, 
    "\x28\xE9\xFA\x9E\x9D\x9F\x5E\x34\x4D\x5A\x9E\x4B\xCF\x65\x09\xA7"
    "\xF3\x97\x89\xF5\x15\xAB\x8F\x92\xDD\xBC\xBD\x41\x4D\x94\x0E\x93",
    0x20);
  memset(n, 0x00, sizeof(n));
  memcpy(n, 
    "\xFF\xFF\xFF\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    "\x72\x03\xDF\x6B\x21\xC6\x05\x2B\x53\xBB\xF4\x09\x39\xD5\x41\x23",
    0x20);
  memset(xG, 0x00, sizeof(xG));
  memcpy(xG, 
    "\x32\xC4\xAE\x2C\x1F\x19\x81\x19\x5F\x99\x04\x46\x6A\x39\xC9\x94"
    "\x8F\xE3\x0B\xBF\xF2\x66\x0B\xE1\x71\x5A\x45\x89\x33\x4C\x74\xC7",
    0x20);
  memset(yG, 0x00, sizeof(yG));
  memcpy(yG, 
    "\xBC\x37\x36\xA2\xF4\xF6\x77\x9C\x59\xBD\xCE\xE3\x6B\x69\x21\x53"
    "\xD0\xA9\x87\x7C\xC6\x2A\x47\x40\x02\xDF\x32\xE5\x21\x39\xF0\xA0",
    0x20);
#ifdef OLD_API
  iRet = ucl_sm2dsa_verify_curve(r,s,xA,yA,in,dInLen,ida,entla,dCfg,a,b,p,xG,yG,n);
  PRINTF("Sm2=(%d)", iRet);
  if(UCL_OK==iRet)
    PRINTF("SM2 Verify OK\n");
#endif//OLD_API
  //preparing the curve domain parameters
  bignum_us2d(tmp_p,SM2FP256_WORDSIZE,p,SM2FP256_BYTESIZE);
  bignum_us2d(tmp_xg,SM2FP256_WORDSIZE,xG,SM2FP256_BYTESIZE);
  bignum_us2d(tmp_yg,SM2FP256_WORDSIZE,yG,SM2FP256_BYTESIZE);
  bignum_us2d(tmp_a,SM2FP256_WORDSIZE,a,SM2FP256_BYTESIZE);
  bignum_us2d(tmp_b,SM2FP256_WORDSIZE,b,SM2FP256_BYTESIZE);
  bignum_us2d(tmp_n,SM2FP256_WORDSIZE,n,SM2FP256_BYTESIZE);
  //initializing the curve domain variable
  sm2vp256.a=tmp_a;
  sm2vp256.b=tmp_b;
  sm2vp256.p=tmp_p;
  sm2vp256.n=tmp_n;
  sm2vp256.xg=tmp_xg;
  sm2vp256.yg=tmp_yg;
  sm2vp256.invp2=tmp_inv2;//will be implicitly computed, shall not be NULL
  sm2vp256.px=NULL;
  sm2vp256.py=NULL;
  sm2vp256.psquare=NULL;
  sm2vp256.curve_wsize=SM2FP256_WORDSIZE;
  sm2vp256.curve_bsize=SM2FP256_BYTESIZE;
  sm2vp256.curve=SM2FP256;

  signature.r=r;
  signature.s=s;
  A.x=xA;
  A.y=yA;
  iRet = ucl_sm2dsa_verification_curve(signature,A,in,dInLen,ida,entla,&sm2vp256,dCfg);
  PRINTF("Sm2=(%d)", iRet);
  if(UCL_OK==iRet)
    PRINTF("SM2 CURVE Verify OK\n");
 }
 
//SM2 curve test with new API and structures introduced in 2.4.9
 int test_ecdsa_p256sm2(void)
 {
   //test vector from draft-shen-sm2-ecdsa-00
   u8 dA[32]={0x12,0x8B,0x2F,0xA8,0xBD,0x43,0x3C,0x6C,0x06,0x8C,0x8D,0x80,0x3D,0xFF,0x79,0x79,0x2A,0x51,0x9A,0x55,0x17,0x1B,0x1B,0x65,0x0C,0x23,0x66,0x1D,0x15,0x89,0x72,0x63};
   //public key
   u8 xA[]={0x0A,0xE4,0xC7,0x79,0x8A,0xA0,0xF1,0x19,0x47,0x1B,0xEE,0x11,0x82,0x5B,0xE4,0x62,0x02,0xBB,0x79,0xE2,0xA5,0x84,0x44,0x95,0xE9,0x7C,0x04,0xFF,0x4D,0xF2,0x54,0x8A};
   u8 yA[]={0x7C,0x02,0x40,0xF8,0x8F,0x1C,0xD4,0xE1,0x63,0x52,0xA7,0x3C,0x17,0xB7,0xF1,0x6F,0x07,0x35,0x3E,0x53,0xA1,0x76,0xD6,0x84,0xA9,0xFE,0x0C,0x6B,0xB7,0x98,0xE8,0x57};

   //signature for the data above
   //with the random number k= 6CB28D99 385C175C 94F94E93 4817663F C176D925 DD72B727 260DBAAE 1FB2F96F

   u8 ida[]={0x41,0x4C,0x49,0x43,0x45,0x31,0x32,0x33,0x40,0x59,0x41,0x48,0x4F,0x4F,0x2E,0x43,0x4F,0x4D};
   u8 entla[]={0x00,0x90};

   u8 msg[]={"message digest"};

   u8 r[SM2FP256_BYTESIZE];
   u8 s[SM2FP256_BYTESIZE];

   int resu;
   int i,loop;

   int configuration;
   ucl_type_ecdsa_signature signature;
   ucl_type_ecc_u8_affine_point A;
#ifdef VERBOSE
   PRINTF("SM2-DSA Fp256 SM3 TEST START -----\n");
#endif
   //verify the KAT
   //using the generic verify, so no possible precomputation
   signature.r=r;
   signature.s=s;
   A.x=xA;
   A.y=yA;
   configuration=(SM2FP256<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(UCL_SM3<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP_TRICK<<UCL_PRECOMP_TRICK_SHIFT);
   resu=ucl_sm2dsa_signature_curve(signature,(u8*)dA,A,msg,14,ida,entla,&sm2fp256,configuration);
   if(UCL_OK!=resu)
     PRINTF("ERROR in signature\n");

   configuration=(SM2FP256<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(UCL_SM3<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP_TRICK<<UCL_PRECOMP_TRICK_SHIFT);
   resu=ucl_sm2dsa_verification_curve(signature,A,msg,14,ida,entla,&sm2fp256,configuration);
   if(resu==UCL_OK)
     {
       PRINTF("ECDSA-SM2FP256-SM3 CURVE SIGNATURE VERIFICATION TEST-1 OK\n");
     }
   else
     {
       PRINTF("ECDSA-SM2FP256-SM3 CURVE SIGNATURE VERIFICATION TEST-1 NOK %d \n",resu);
       return(UCL_ERROR);
     }
   configuration=(SM2FP256<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(UCL_SM3<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP_TRICK<<UCL_PRECOMP_TRICK_SHIFT);
   resu=ucl_sm2dsa_verification(signature,A,msg,14,ida,entla,configuration);
   if(resu==UCL_OK)
     {
       PRINTF("ECDSA-SM2FP256-SM3 SIGNATURE VERIFICATION TEST-1 OK\n");
     }
   else
     {
       PRINTF("ECDSA-SM2FP256-SM3 SIGNATURE VERIFICATION TEST-1 NOK %d \n",resu);
       return(UCL_ERROR);
     }


   //loop on sign+verify cycles
   //only the ECDSA random number is changing
   loop=LOOP;
   PRINTF("ECDSA COMPUTATION CURVE SM2-Fp256 SIGN+VERIFY sm2, loop=%d\n",loop);
   for(i=0;i<loop;i++)
     {
       //generating a new signature and verifying it with the direct routine (so using precomputation)
       configuration=(SM2FP256<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(UCL_SM3<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP_TRICK<<UCL_PRECOMP_TRICK_SHIFT);
       resu=ucl_sm2dsa_signature_curve(signature,(u8*)dA,A,msg,14,ida,entla,&sm2fp256,configuration);
       if(UCL_OK!=resu)
	 PRINTF("ERROR in signature\n");
       configuration=(SM2FP256<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(UCL_SM3<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP_TRICK<<UCL_PRECOMP_TRICK_SHIFT);
       resu=ucl_sm2dsa_verification_curve(signature,A,msg,14,ida,entla,&sm2fp256,configuration);
       if(UCL_OK!=resu)
	 {
	   PRINTF("ECDSA SIGNATURE TEST-LOOP SM2-Fp256 NOK %d \n",resu);
	   return(UCL_ERROR);
	 }
     }
   PRINTF("ECDSA COMPUTATION SM2-Fp256 SIGN+VERIFY sm2, loop=%d\n",loop);
   for(i=0;i<loop;i++)
     {
       //generating a new signature and verifying it with the direct routine (so using precomputation)
       configuration=(SM2FP256<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(UCL_SM3<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP_TRICK<<UCL_PRECOMP_TRICK_SHIFT);
       resu=ucl_sm2dsa_signature(signature,(u8*)dA,A,msg,14,ida,entla,configuration);
       if(UCL_OK!=resu)
	 PRINTF("ERROR in signature\n");
       configuration=(SM2FP256<<UCL_CURVE_SHIFT)^(UCL_MSG_INPUT<<UCL_INPUT_SHIFT)^(UCL_SM3<<UCL_HASH_SHIFT)^(UCL_NO_PRECOMP_TRICK<<UCL_PRECOMP_TRICK_SHIFT);
       resu=ucl_sm2dsa_verification(signature,A,msg,14,ida,entla,configuration);
       if(UCL_OK!=resu)
	 {
	   PRINTF("ECDSA SIGNATURE TEST-LOOP SM2-Fp256 NOK %d \n",resu);
	   return(UCL_ERROR);
	 }
     }
SM2Test();
   PRINTF( "SM2-DSA Fp256 SM3 TEST END -----\n");
   return(UCL_OK);
 }
#endif//SM2

