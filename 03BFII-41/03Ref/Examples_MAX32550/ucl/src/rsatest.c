
/*
 * rsatest.c --
 *
 * ----------------------------------------------------------------------------
 * Copyright (c) 2015, Maxim Integrated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Maxim Integrated nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY MAXIM INTEGRATED ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

//1.0.0: initial versioned release jul-2014
//1.0.1: update with emv advt, apr 2015
/** Global includes */
#include <ucl_testing_config.h>
#ifdef RSA
#if defined(__max32550)||defined(__lighthouse)||defined(__max32555)||defined(__yumen)
#include <config.h>
#include <ucl/ucl_config.h>
#include <errors.h>
#include <string.h>
#endif

/** Other includes */
#ifdef SYSTEM_JIBE
#include <jibe_gcr.h>
#include <jibe_uart.h>
#endif//jibe
#ifdef SYSTEM_LIGHTHOUSE
#include <mml_gcr.h>
#include <mml_gcr_regs.h>
#include <mml_uart.h>
#include <printf_lite.h>
#include <ucl/lighthouse_crypto.h>
#endif

#include <ucl/ucl_config.h>
#include <ucl/ucl_defs.h>
#include <ucl/ucl_retdefs.h>
#include <ucl/ucl_types.h>
#include <ucl/ucl_sys.h>
#include <ucl/ucl_stack.h>
#include <ucl/ucl_sha1.h>
#include <ucl/ucl_sha256.h>
#include <ucl/ucl_hmac_sha256.h>
#include <ucl/ucl_rng.h>
#include <ucl/ucl_info.h>
#include <ucl/ucl_des_ecb.h>
#include <ucl/ucl_aes_ecb.h>
#include <ucl/ucl_rsa.h>
#include <ucl/ucl_3des.h>
#include <ucl/ucl_3des_cbc.h>
#include <ucl/ucl_stest.h>
#include <ucl/ecdsa_generic_api.h>
#include <ucl/ucl_data_conv.h>
#include <ucl/ucl_rsa2vs.h>
#include <ecdsatest.h>
#include <aesgcmtest.h>
#include <dsatest.h>
#include <trngtest.h>
#include <sp80056test.h>
#include <rsapkcs1test.h>
#include <rsax931test.h>
#include <destest.h>
#include <3destest.h>
#include <shatest.h>

/** Local includes */
#include <uart_config.h>
#ifdef SYSTEM_JIBE
#include <printf_lite.h>
#include <private.h>
#endif

#ifdef SYSTEM_LIGHTHOUSE
#include <printf_lite.h>
#include <private.h>
#include <ucl/lighthouse_crypto.h>
#include <io.h>
#endif

#include <string.h>

#define UCL_RSA_KEY_MAXPRE (UCL_RSA_KEY_MAXSIZE/4)
#define UCL_IS_PRIME UCL_TRUE

 u32 modulus2048[]={0xc0f96c0d,0x8001b04e,0xe398d132,0x98b1ea41,0x135b9680,0x5cfcc5ab,0xbfc4b180,0x2c346181,0xaebae8ae,0x4932c10e,0x7791b18c,0xfb9b59c1,0x923f0caf,0x96198ae1,0x30d3f8b5,0x489c0544,0x941c5c76,0x00a6d1a2,0x7c8b7cce,0x7cb6661c,0x0711d93c,0xda30b106,0x665afd89,0x1a102a46,0xa114f8c7,0x02686ff6,0x32c875bd,0xd8eb24b1,0xa7e4c889,0x4a9d20f6,0x10711949,0x6f23ebfa,0xd8829a06,0xa0866fa5,0xe150f07d,0xa4de0dd1,0x445f59e2,0x5ab0826b,0x6d176079,0xa659d210,0x2cddb81f,0xc0ab1412,0xd2b67671,0x4320d414,0xd29fd439,0xe14ba746,0x3e2b9ec4,0x3db43ef8,0xf24dc1e7,0x53706f5e,0x0473051e,0x4265c93a,0x82c0bba4,0x04c5562e,0x1b8387d4,0xe956dd25,0x59ead990,0x11c92d52,0x93d401e5,0xc77527d8,0xe291117d,0x2d14dc64,0x1f3f1fd0,0xcc79df3d};
 u32 p2048[]={0xd40fe027,0x28bf8547,0x61b50002,0x0230151d,0x4b6ea390,0xb1ca719e,0x0a87b883,0xe9843bee,0x2851a518,0x80d1c12b,0xc9ac0ea6,0x6e3270ca,0x6810e612,0xc7a7653c,0x6cb6d6dc,0x4261ec29,0x2eee84a0,0x32dd7ce2,0x965b8928,0x4482e211,0x6c4de7c4,0xd769abeb,0xb64a7880,0x828a04db,0x0d93bdd2,0x7c37b0cd,0x14df7c5e,0x14b3d146,0x9ef0a93c,0x81dce2f7,0x98d56317,0xf1c2e761};
 u32 q2048[]={0x9948feab,0x40d83152,0x95ef66ca,0x39330706,0x462f443d,0x9a1ff4cc,0x01913de4,0xc3511ca1,0x15cf9aa8,0x60242146,0x70ccfa01,0x49170fcb,0x446c038a,0x1a647a62,0x7b759e05,0xe99d99a1,0xc7162e80,0xf114f4af,0x11954f16,0x1a461119,0xde524fbc,0xf555fed9,0x9fdd3c58,0xc082a488,0xc91bf687,0xed2ebba0,0xbd53cafa,0x8fc54876,0x64a5007b,0x364c56ba,0x4677606c,0xd884cf07};
 u32 d2048[]={0xB4397D1,0xF072DAAD,0xE5E272A7,0xC1FE4768,0x55082A51,0x65F8C19D,0x24F19DFE,0x3A9B1752,0xF64030FD,0x4821419A,0x32E0D79D,0x8F82C946,0x8E37E9C0,0xEFE79FFB,0xCD5C1FEA,0x036D962C,0xDA611373,0x5591DBFE,0xD88A7259,0x8B0CFE78,0xED54B8A4,0xBD57B55B,0x11B2AF11,0x3DF45D96,0x6BD384FE,0x07CBB9F9,0x84A79219,0x295F8950,0x2A9AC809,0x24C99CBF,0x63680C94,0xD9AB1212,0x16ABD07D,0xA849B4F3,0x80222B3A,0x0E24AEF8,0x42E1CE84,0x613BFF35,0x5B9E0F7B,0x017A1F1C,0x7B0C078A,0x5EA6F25D,0xB112FF97,0x3671420D,0xB1EE012A,0x6CE0AF25,0xB03A6970,0x93F992D7,0x86E32C1D,0xFCFA393A,0x2DC7FE74,0x12468951,0xA8FBE6CA,0x4A464F5D,0xCBCED01F,0x1AB31C87,0xCB67AFFB,0x063831C4,0x861484DE,0x22F37A6F,0x432CCC49,0x0651B97E,0x19B5790C};

 u32 dp2048[]={0x55c1b4b5,0xe56f5437,0x059d7878,0xd8f44e42,0xdda2d84a,0xddc7a4f1,0xe8e411e6,0x931c9209,0xb08ade5f,0x0036a278,0xfbc52d60,0x1ddb97e9,0xd73d37b9,0x406c21f8,0xa24d95c7,0x8f848f58,0x8729a282,0x4ef1ee0b,0x6db4f362,0xe92fcb34,0x435a20eb,0xe02ce5b6,0x2779136b,0x4a762449,0x00867f13,0x086d75ae,0xc2f20cf1,0x619a030d,0xa56e0172,0x5cb2a824,0xb4fc5baf,0x291291b8};
 u32 dq2048[]={0xf9e3b0d5,0x3ad52ef6,0x7fe1bb50,0x4febc1e0,0x9242a9f2,0x1f6ee7cb,0x49309470,0x06b21b85,0xa606542c,0x2b65c6cc,0xdc34e675,0xf450b431,0xa4674f06,0xe21bdc88,0xcbfd2382,0xae7b895c,0xc846f73d,0x1b41eb95,0xc4e20b7c,0xc2c459f1,0xb4676d7a,0xc4f471b3,0x16d193b5,0xa05d6fe8,0x34bca63c,0xf84d94aa,0x326a9778,0x35e597e0,0x917e2dc3,0xfbe52893,0x491d4649,0x610ed7c7};
 u32 qinv2048[]={0x617a6a7a,0x49fd65e9,0xe10b1736,0xc6fce97a,0x439560af,0xd71629c6,0xe84a96db,0x7f888332,0x283ead7b,0xec7e8a8a,0xf4f9f337,0x0115a02a,0x5f0fdd8b,0xbe43ff43,0x39e2c71b,0x93ce9614,0xaca90d67,0x73fb8282,0xe5148cbe,0x4ff65cc8,0x2c270234,0xd0893999,0xa98d5124,0x543f422e,0xaf418372,0x9c90f4aa,0x13deaff7,0x9f109920,0xddd5e230,0x27565c5e,0x3147efc1,0xaa9434ae};

 u32 m2048[]={0x62cddc15,0xbb0c91fc,0xf4c0169f,0x2c207c87,0xb4096a15,0xf2c2ab60,0xe90320af,0x4165d0fb,0xb8cc4246,0xc786d4e3,0x181df23f,0x745beae4,0x07f215c7,0xbbd1b5ad,0x19303639,0xc0ada00f,0x27921de4,0x24b4594a,0xdc035c6f,0x4c982801,0xa93c3b34,0xb108db46,0x5ca1d507,0x7a6be752,0x00d25df1,0x779453c1,0x8d1e71c7,0x2d13d961,0xdb380a51,0x391bf36d,0x139635f6,0x60d167d6,0xb919a0c1,0x422a6b3d,0x93384687,0xf8a7bec1,0x5b6df359,0x097d2b42,0x1e020232,0xa58199b2,0xfa0f9afb,0x6d9414e1,0x9436eabb,0x04a8e39c,0x921c7365,0x43126d6b,0xb6a277c5,0x211de176,0xe3c9f8c2,0x21f2b67b,0x5e9b4bb3,0x1f8af161,0x82e13526,0x9aedf4bb,0x16b7c56b,0x9ed71be0,0xee02cdb7,0x6088c19e,0x14c1618e,0x2f966fb4,0xb88ba47f,0x3e7d242b,0x98600c8f,0xcc79df3c};
 u32 resu2048[]={0x414D52A2,0x0BE3D9C6,0x87BA6293,0x1D61F496,0xD028A4F2,0xE16FD7C1,0x2586AD78,0x018311C3,0x45AB957F,0x926581A1,0x2E2A3464,0x1D7C466A,0xD9F47437,0xA9AD54E1,0xB47A6ABE,0xFDAC91A9,0xFE02731C,0x380F3FBF,0xDCD1B4F2,0x271185D4,0x9BC9D50E,0xFFE07E1A,0x6670327F,0xC2C891B8,0x71CF8EDB,0x1E7B45CE,0xB9589347,0x4A6ED742,0x48EDFAAC,0x0296472D,0x65F31EA9,0x0E4DC4AC,0x217A598F,0xBCB0F790,0x4C48CB39,0x9AE14ABD,0x5EBE8BB8,0xFFC4D02C,0x855DBEE4,0x369D948A,0x7EF641AF,0xF34AEAE7,0x9C1D4F25,0x476EA55B,0xA83C91B1,0x1B7AD32D,0x7726A4DE,0x45F729A6,0x2A05E635,0x311F45A9,0x7C9C13AC,0x2E3CCB4F,0x000500AC,0xC31AD92A,0x193FDFF5,0x2C2F4715,0x8FE816BF,0xC0E84062,0x3295EAA6,0xF1AEF128,0xAFC9F02E,0x4B09EA81,0xC0084FA7,0x29DA4881};

  u32 _n2048_[]={0xccef35ad,0x4e852035,0x382c6c8b,0x19ad8264,0xab320995,0x11fc65ef,0xbb3210e4,0x0f134b3e,0xca5648b1,0xd73f1e2a,0x6d39efac,0x22c189d1,0x4aaace36,0x528bcff6,0xab8e6de9,0x585346ff,0xd170128a,0xe3bdb56a,0x0b9eb569,0x26e79c71,0xbb6ea426,0x50128798,0x9079a5a6,0xcbf8d6f4,0x4933c736,0x6768e64d,0xb4c5256c,0x7b2379eb,0x16e0811c,0x38ac2e7b,0xbfeb2022,0x499318c6,0x85a750cf,0x04919eae,0x2747e68b,0x0e0526a5,0xa6219b9e,0xbcc4804e,0xf2e8053c,0x5c85f281,0xa78dc51e,0x1647b2c7,0x01edeb74,0x8f52f55d,0x95aff280,0xe61f2937,0x67a9e68a,0x4472555e,0xafb400ca,0x4a005d96,0x3a4b9b03,0x5f289d23,0xec3936c4,0x2817f56f,0x546cfa9f,0x103418bf,0x2d5fdc0b,0xe7a1bf40,0xb8f8737e,0x9ff99837,0x23310958,0xf979d735,0xa070831d,0x98b26e6c};
 u32 _p2048_[]={0x4a92dc13,0x6b2ac748,0x117bd17f,0x79319c1e,0xa1befb2e,0xd654926d,0xce0e1dc8,0x88e694d3,0x1ef2f569,0x91c37694,0x35938479,0x8813543e,0x74bd737c,0xa3636e4e,0x2faa6b2f,0x4d7edab9,0x3d7c77bf,0x617703b9,0x0e2370aa,0xf3df83db,0xfb093182,0x2ba1a926,0x2fb25330,0x4a2ae713,0xb1e975a2,0xd1f2451b,0x681ad361,0x3d46c9c8,0x4de342ae,0xd1ff7bff,0xee621b4a,0xcbaaaec7};
 u32 _q2048_[]={0x64605f3f,0x083f1d17,0x46520d66,0xeaecb552,0xeaf4795f,0x815ace1b,0xb2888652,0xd941fef2,0x20a9de38,0x031f7e67,0x80a9b23e,0x353050e8,0xf90a3b85,0xc4ce6738,0x171efaa9,0xd5690538,0x3481a09a,0x89d80cb2,0xc1ae4712,0x9187cdd6,0xc7a82eb4,0xd45d695e,0xa7ecf8db,0xeb4c5342,0x97e4e27d,0x8bdddf0e,0x8df98f24,0x9aa01859,0x4788913b,0x1451b92a,0xd8787c2c,0xbfeeedfd};
 u32 _d2048_[]={0xcd4fd911,0x33156492,0xb309e35e,0x355f839d,0x5b6f8eb6,0x95a1c637,0x22edc853,0xebf98e1c,0x0b9a9ab3,0x7c973dd1,0x02faa59f,0xe84c8017,0x88e4f1b3,0x1a4fedd9,0x14544abb,0x25d367fe,0x979c452b,0x0dc5af25,0x61718427,0x974a7526,0x06a04783,0xbeafa3f7,0xf9ff4745,0xdea744d1,0x31c1c22a,0x8e29aacd,0x60ceacce,0x14dd79a7,0x6ce8be6f,0xb80eb86d,0x4620c015,0xbf875201,0x8a4eb858,0x40b3f096,0x6ba4f166,0x921fa0ef,0x75d34b1d,0xdeff1ba1,0xa2d0e8ba,0xdc3d9379,0xb78bed8f,0x79e9c570,0x5c5bc480,0x605ab920,0x807bca53,0xa0510c2b,0xff7890ca,0x8a0fa1b1,0xb3f210c4,0xf75ba3b2,0x77e0d822,0x5ce71a9a,0x39a174a4,0xae4e79f9,0x62da5c24,0xf6f37c8b,0xd7cb7587,0x676ae4af,0x2b78116d,0x041e4656,0x112f1cbb,0x877fef03,0xa5768711,0x04fc6e96};
//KAT for _n2048
 u32 _m2048_[]={0xd0bdc934,0x4ce9173a,0x61c2dd50,0x5a28879a,0x61eafdef,0xebfb522e,0xa6827432,0x7f0b8a85,0x084f478f,0xd3f04108,0x865c85ed,0x15b1369e,0x1122e367,0xbfce9af4,0x0e5e5e41,0x22e25bd9,0xc60e0690,0x4c57ce12,0x273133ef,0x69d125d2,0x23f56d62,0xa8ea47b8,0x0033ffd7,0x43b76351,0x8faa90c5,0x8a644897,0xd65b8201,0xb3b463a5,0xa7301248,0x7aee5194,0xcc46362a,0xe457366a,0x19e3ef84,0xea383744,0x36ce8f9f,0x236fa368,0x95560d40,0xf705b121,0x12b78df5,0x8c2a5d58,0x3ae1f190,0x1e09a1ac,0x0fd6bf68,0x517de484,0x2d776550,0x23be3dec,0x10edadcb,0x00f073b2,0xbc8d9bc1,0x1298f943,0x06eb3850,0xe060877d,0xf7d04cd2,0x0bd5112f,0xa7c3f6ee,0xcbfa4aef,0x30a2ed98,0x5a105988,0xe9c04558,0x036807ac,0xe4b82956,0xf64b8138,0x4084a88d,0x98b26e6b};
//KAT answer for _n2048
 u32 _c2048_[]={0x7f31200c,0x9a386ad9,0xd3d5f19c,0x015cffdd,0x1b103cc8,0x4bbc923d,0xff19a0aa,0x801537a5,0x0271c3cd,0x2ef8e61d,0xd3a78cb6,0xecf7a57a,0x10640b81,0x1ef2288f,0xcd7edf95,0x9630fbc4,0x6e787f86,0xdb0d9336,0x4bd34004,0x5ad5833c,0x2924f36a,0xe8357797,0x538a4e0d,0x24aa5638,0xac97e7b1,0x8b8f7d92,0x8e6c0d69,0xc90b85f7,0xa5bdc56e,0x4bb965bc,0x597efedb,0x1d987f7b,0x9f451972,0x5f7672bb,0x3632d6a4,0x887bb7c3,0x11c50d57,0x4b3b087a,0xe4361c7a,0x44ec3d21,0x2d1c0736,0x8b3332f1,0x21455d60,0xd26f5a90,0x152e0b0f,0x5f1cdcd5,0x4a7ea45a,0xdfe3f067,0x71484ee9,0xd4905b64,0xcd2551ae,0x49327765,0x1b63bb7b,0xccc5b7e9,0xa6698b99,0x433cc38f,0xda9d9c8b,0xf12f7bc9,0x7b935e7e,0x132199e9,0x328f7374,0x4f303ac8,0x4f847738,0x4a1ec7e4};
 u32 _e2048_[1] = { 0x10001 };


//KAT for RSA-1024
 u32 _n_[32] = {
  0x091dbdcb, 0x46f8e5fd, 0xca2a8f59, 0xe2537298, 0xf6c1687f,
  0x527a9a41, 0x7b61a51f, 0xe0aab12d, 0x4598394e, 0x8834b245,
  0x06095374, 0xee6a649d, 0xd93a2584, 0x3ee6b4b7, 0xdfc73772,
  0xafb8e0a3, 0x5b8b807f, 0x19719d8a, 0x60e1ec46, 0x76ed520d,
  0xeb6fcd48, 0x61ea48ce, 0x035c02ab, 0xb8dfbaaf, 0x7454f51f,
  0x40d6b6f0, 0xd41043a4, 0x368d07ee, 0x9da871f7, 0x2338ac2b,
  0x0682ce9c, 0xbbf82f09 };

 u32 _p_[16]= {
  0x58fb6599, 0x7541ba2a, 0x459d1f39, 0x5b252176, 0xaa040a2d, 0x7e28fae7,
  0x6e5d1e3b, 0x124ef023, 0x3d84f632, 0x93b81a9e, 0xaef4fda4, 0x99eb9f44,
  0xa1b56001, 0x08810b10, 0xb1b9b3c9, 0xeecfae81 };

 u32 _q_[16] = {
  0xaf461503, 0xa441e700, 0x4d0416a5, 0xce335252, 0x3204b5cf, 0xea0da3b4,
  0x66b42e92, 0x9840b416, 0x028b9d86, 0x5a0f2035, 0x8866b1d0, 0x3f6c42d0,
  0xaad1d935, 0x341233ea, 0x27f453f6, 0xc97fb1f0 };

 u32 _qInv_[16] = {
  0x798039f7, 0x66edfb25, 0xe698ea36, 0x2e0f9656, 0x402b4e9e, 0x67a967bf,
  0x4f5883b1, 0xc9863215, 0x39e2119f, 0x93077fcd, 0x34538850, 0x80f271f7,
  0xae9423b3, 0x8d265bdb, 0xbb630119, 0xb06c4fda };

 u32 _dp_[16] = {
  0x1f67c981, 0x74adc93c, 0x910a4741, 0x202b38fc, 0x692e9a2e, 0xff59c1f7,
  0xeab77414, 0xd9490975, 0x51f2b13e, 0xac9b54b0, 0x0183a4d0, 0xeb07dddc,
  0xfcd69a5a, 0xe4e24023, 0x3eba0337, 0x54494ca6};

 u32 _dq_[16] = {
  0x9836da3d, 0x39f9245a, 0x849807fe, 0x1b99a495, 0xe47a220d, 0xe931fd8a,
  0x6f8ae342, 0xf9803f8f, 0x4c3146a7, 0x5c0556a9, 0x8a7e991c, 0x61adbd3a,
  0x78864ca9, 0x0351b7f8, 0xff0af075, 0x471e0290};

 u32 _e_[1] = { 0x11 };
 u32 _d_[32] = {
  0x5B1CB3C1, 0x463A4BC8, 0xB8883FE4, 0x9428C2B7, 0xCC4894AF, 0xFBE1A1CE,
  0x74A13EDD, 0x9926ED4F, 0xF5D20A93, 0xD38DC3BE, 0xC56C092C, 0xE56AAF68,
  0xA9529444, 0x111C76F1, 0x50ACCFBC, 0x7FF3AD59, 0xC93EDAC9, 0x7FDCB82E,
  0x82A939E3, 0x870DA2C0, 0x392669D6, 0x65745E5C, 0x998D6BC4, 0x9410B3C7,
  0x579641B2, 0x84813801, 0x0668B427, 0x3F31251E, 0x30C1CDF8, 0xC4B988DB,
  0x41FAF289, 0xA5DAFC53 };

 u32 _m_[32] = {
  0x4d353e2d, 0xd2f1b76d, 0x5281ce32, 0x7bc27519, 0x2f3ac14f, 0x0448db97,
  0xd095aeb4, 0x82fb3e87, 0x1be392f9, 0x43581159, 0xd5024121, 0xb48d2869,
  0x2baad29a, 0xa1b7c136, 0xf47728b4, 0x4cdcfe4f, 0x839a2ddb, 0xff8ae10e,
  0x25c9c2b3, 0xf93edcfb, 0x4626f5af, 0xd7e0b2c0, 0xb4251f84, 0xc31b2e8b,
  0xa8f55267, 0x5c68f1ee, 0x26dcd87d, 0xca82310b, 0x504b45e2, 0x6350e329,
  0xace9e300, 0x00eb7a19};

 u32 _c_[32] = {
  0x063e0955, 0xe96838d6, 0x85d8b50d, 0x51a74ddf, 0xa74e558d, 0xc9130ade,
  0x8700c84f, 0xda9536ad, 0x40e5bb48, 0x2ef5c9c1, 0x4a90fe9f, 0x24c2ca2f,
  0xd6eb96a0, 0x70e5783b, 0x1d654a19, 0x6d84b1c3, 0x8def04bb, 0x68dfeae2,
  0x2314a679, 0x53c11df8, 0x4f872cf6, 0xda5d1c0b, 0x069e5268, 0x63722017,
  0x74c95df7, 0x94ccd300, 0x996fc82a, 0x39a33d1e, 0x7e9bf2a0, 0xb44a7ab8,
  0xc0a5397b, 0x1253e04d};


int test_openssl_key_use(void)
{
  u8 modulus[]={0xeb,0x01,0x1b,0xef,0xcd,0x7c,0x37,0xc6,0x9b,0x37,0xe3,0x94,0x72,0x42,0xba,0xdd,0x8d,0xef,0x0a,0x57,0x05,0xaf,0x7b,0x79,0x04,0x05,0xd6,0x99,0xd6,0x68,0x04,0x2b,0xf8,0xee,0x1c,0xd5,0x21,0x65,0xdc,0x33,0xdc,0x02,0x6a,0x32,0xe3,0xf1,0x2d,0x30,0xe1,0x2f,0x22,0x8e,0x49,0x69,0xc5,0x19,0xb8,0x86,0xc9,0x1d,0x52,0x2e,0xde,0x36,0x9f,0xff,0xc0,0x43,0x27,0xb0,0x03,0x13,0x41,0x48,0xd0,0xab,0x93,0x69,0x70,0x68,0x02,0x1c,0xb0,0xdf,0xac,0x71,0x7d,0xa0,0xb1,0x98,0x08,0x5b,0x7e,0x7f,0xd4,0x3f,0xa7,0xe2,0x27,0x39,0xea,0x09,0xc2,0x77,0x56,0x48,0x97,0xc3,0xca,0x25,0xb7,0xe5,0x5d,0x8e,0x55,0x3e,0x65,0x7b,0x44,0x19,0xf1,0x9b,0x6b,0xc4,0x0d,0x2f,0x5f,0xe9,0x97,0xa8,0xaf,0x2f,0x6c,0xbc,0x10,0xfd,0x3d,0x28,0x47,0xac,0xe6,0x06,0x59,0xd0,0x2f,0x22,0x52,0x00,0x99,0x9a,0xe3,0x94,0xec,0x10,0x06,0xb5,0xb4,0xad,0x3b,0xfe,0xf6,0x8f,0xcf,0x68,0xab,0x75,0xaf,0x9f,0x7a,0x3e,0x23,0x80,0x86,0x54,0x44,0x72,0x52,0xeb,0xcd,0x23,0xdd,0x7b,0xb9,0x1e,0x8a,0xe9,0x46,0xcd,0xd9,0x58,0xe0,0x39,0xe9,0x48,0xb5,0x4c,0x84,0xb7,0xa7,0x0c,0x7b,0xc2,0xfb,0x78,0xff,0x77,0x4d,0x3c,0x47,0x25,0x75,0x87,0x82,0xe6,0x45,0xb6,0xab,0x0d,0xd4,0xa6,0x73,0x3a,0xf7,0x96,0x91,0x12,0x14,0x83,0xee,0xcb,0xe8,0x24,0xd6,0x73,0xd1,0x61,0x3a,0x58,0x25,0x22,0x47,0xd4,0xf2,0x80,0xd0,0x20,0xbe,0xd1,0x29,0x26,0xd0,0x6b,0x43,0x69,0x7d,0x03};
  u32 publicExponent65537[1]={0x10001};
  u8 MessageToEncrypt[40]={0x3,0x1,0x4,0x0,0x0,0x0,0x33,0x6e,0x32,0x65,0x88,0x5b,0xc,0xa3,0xb3,0x49,0xbd,0x8e,0x39,0x6e,0x24,0x73,0xef,0x8f,0xc,0x61,0x74,0x0,0x4f,0x81,0x95,0xd6,0x96,0x2a,0xe3,0x44,0x25,0x64,0x0,0x0};
  u8 privateExponent[]={0xa4,0x65,0x54,0x3b,0xbf,0x0d,0xc4,0x9e,0xe4,0xfa,0x85,0xf3,0xd4,0xb2,0xa5,0xb2,0x53,0x96,0x03,0x2f,0xb9,0x44,0x77,0x25,0xc3,0x10,0xaa,0x7d,0x57,0xa5,0xd0,0x35,0x4a,0xa0,0x97,0xfe,0xe8,0xac,0x2f,0x0d,0x00,0x3d,0x98,0x39,0x1d,0x88,0x1b,0xca,0xf3,0xdc,0x5b,0x5a,0x1a,0x35,0x29,0xb2,0xc2,0x89,0x57,0xab,0x71,0x50,0x64,0x16,0xe6,0x7a,0xac,0xee,0xcd,0x96,0xad,0xb0,0x0c,0x9d,0x79,0x8c,0x6d,0x44,0xf7,0x63,0x6b,0x06,0xd3,0x1c,0xc5,0xaf,0x66,0xe8,0xc1,0x13,0xcf,0xd4,0xe1,0x7b,0x5e,0xe9,0x60,0xf2,0x2d,0xea,0xaf,0xb4,0x40,0x1b,0xe7,0x7a,0x44,0xe0,0xac,0x4b,0x12,0x88,0x1b,0x98,0x74,0x3d,0x80,0x14,0x69,0x21,0x95,0x08,0xda,0xac,0x7d,0x64,0xc4,0xbc,0x77,0x2d,0x58,0x03,0x0f,0xf5,0x42,0x2b,0x9e,0x62,0xfe,0xa7,0x7d,0x83,0x81,0x4d,0x00,0x52,0x85,0x76,0xd3,0x67,0x55,0xbe,0x53,0x63,0xf5,0x0b,0x9e,0xdc,0x56,0x34,0x22,0x1d,0x2c,0x6f,0xb7,0x30,0x04,0x13,0x0c,0x24,0xdf,0x90,0xb7,0x65,0xd2,0x64,0x7c,0x9d,0xcb,0x17,0x5a,0x8b,0xad,0xec,0xa6,0x5b,0x2d,0xb5,0xcc,0x9a,0xf0,0xe5,0xab,0x37,0x41,0x78,0x82,0xb9,0x7a,0x1e,0x2f,0x5d,0xc8,0xcc,0xc8,0x45,0xfc,0x67,0x12,0x41,0xfa,0x79,0x5e,0xb9,0x0b,0x39,0x6f,0xe2,0xf4,0xb9,0x68,0xb4,0x02,0xd3,0xc6,0x34,0xdb,0x82,0x44,0x07,0x40,0xc8,0xae,0x92,0x78,0xc2,0xc6,0xb2,0xa0,0x42,0xae,0x8d,0xb9,0xdd,0x4b,0x82,0x60,0x72,0x45,0x95,0x1d,0x74,0x6b,0x48,0xd1,0xd1};

   u32 modulus32[64];
   u32 result32_bis[64];
   u32 message32[64];
   u32 private32[64];
   u32 result32[64];
   u8 result[256];
   int i;
   int err;
   PRINTF("OPENSSL KEY USE ");
   PRINTF("modulus size: %d\n",sizeof(modulus));
   ucl_data_os2int(modulus32,sizeof(modulus)/4,modulus,sizeof(modulus));
   ucl_data_os2int(private32,sizeof(modulus)/4,privateExponent,sizeof(modulus));
   ucl_data_os2int(message32,sizeof(modulus)/4,MessageToEncrypt,sizeof(MessageToEncrypt));
   err=ucl_rsa_encryptBlock(result32,message32,publicExponent65537, 1,modulus32, sizeof(modulus)/4);
   if(UCL_OK!=err)
     {
       PRINTF("err=%d\n",err);
       return(UCL_ERROR);
     }
   ucl_data_int2os(result,sizeof(modulus),result32,sizeof(modulus)/4);
   PRINTF("encryption result:\n");
   for(i=0;i<(int)sizeof(modulus);i++)
     PRINTF("%02x",result[i]);
   PRINTF("\n");
   err=ucl_rsa_decryptBlock(result32_bis,result32,private32,modulus32,sizeof(modulus)/4);
   ucl_data_int2os(result,sizeof(modulus),result32_bis,sizeof(modulus)/4);
   PRINTF("decryption result:\n");
   for(i=0;i<(int)sizeof(modulus);i++)
     PRINTF("%02x",result[i]);
   PRINTF("\n");
   return(UCL_OK);

}

 //this test performs a issuer certificate verification (test 18)
 //using the 1984-bit Visa Test Public key (annex A.3)
 // reference: ADVT User Guide 6.0 (June 2010)
 int test_emv_advt(void)
 {
   int err;
   u8 visa_puk_1152[]={0xBE,0x9E,0x1F,0xA5,0xE9,0xA8,0x03,0x85,0x29,0x99,0xC4,0xAB,0x43,0x2D,0xB2,0x86,0x00,0xDC,0xD9,0xDA,0xB7,0x6D,0xFA,0xAA,0x47,0x35,0x5A,0x0F,0xE3,0x7B,0x15,0x08,0xAC,0x6B,0xF3,0x88,0x60,0xD3,0xC6,0xC2,0xE5,0xB1,0x2A,0x3C,0xAA,0xF2,0xA7,0x00,0x5A,0x72,0x41,0xEB,0xAA,0x77,0x71,0x11,0x2C,0x74,0xCF,0x9A,0x06,0x34,0x65,0x2F,0xBC,0xA0,0xE5,0x98,0x0C,0x54,0xA6,0x47,0x61,0xEA,0x10,0x1A,0x11,0x4E,0x0F,0x0B,0x55,0x72,0xAD,0xD5,0x7D,0x01,0x0B,0x7C,0x9C,0x88,0x7E,0x10,0x4C,0xA4,0xEE,0x12,0x72,0xDA,0x66,0xD9,0x97,0xB9,0xA9,0x0B,0x5A,0x6D,0x62,0x4A,0xB6,0xC5,0x7E,0x73,0xC8,0xF9,0x19,0x00,0x0E,0xB5,0xF6,0x84,0x89,0x8E,0xF8,0xC3,0xDB,0xEF,0xB3,0x30,0xC6,0x26,0x60,0xBE,0xD8,0x8E,0xA7,0x8E,0x90,0x9A,0xFF,0x05,0xF6,0xDA,0x62,0x7B};
   u8 pubexp_1152[]={0x03};
   u8 issuer_cert_1152[]={0x8B,0x39,0x01,0xF6,0x25,0x30,0x48,0xA8,0xB2,0xCB,0x08,0x97,0x4A,0x42,0x45,0xD9,0x0E,0x1F,0x0C,0x4A,0x2A,0x69,0xBC,0xA4,0x69,0x61,0x5A,0x71,0xDB,0x21,0xEE,0x7B,0x3A,0xA9,0x42,0x00,0xCF,0xAE,0xDC,0xD6,0xF0,0xA7,0xD9,0xAD,0x0B,0xF7,0x92,0x13,0xB6,0xA4,0x18,0xD7,0xA4,0x9D,0x23,0x4E,0x5C,0x97,0x15,0xC9,0x14,0x0D,0x87,0x94,0x0F,0x2E,0x04,0xD6,0x97,0x1F,0x4A,0x20,0x4C,0x92,0x7A,0x45,0x5D,0x4F,0x8F,0xC0,0xD6,0x40,0x2A,0x79,0xA1,0xCE,0x05,0xAA,0x3A,0x52,0x68,0x67,0x32,0x98,0x53,0xF5,0xAC,0x2F,0xEB,0x3C,0x6F,0x59,0xFF,0x6C,0x45,0x3A,0x72,0x45,0xE3,0x9D,0x73,0x45,0x14,0x61,0x72,0x57,0x95,0xED,0x73,0x09,0x70,0x99,0x96,0x3B,0x82,0xEB,0xF7,0x20,0x3C,0x1F,0x78,0xA5,0x29,0x14,0x0C,0x18,0x2D,0xBB,0xE6,0xB4,0x2A,0xE0,0x0C,0x02};

   u8 visa_puk_1408[]={0x99,0x6A,0xF5,0x6F,0x56,0x91,0x87,0xD0,0x92,0x93,0xC1,0x48,0x10,0x45,0x0E,0xD8,0xEE,0x33,0x57,0x39,0x7B,0x18,0xA2,0x45,0x8E,0xFA,0xA9,0x2D,0xA3,0xB6,0xDF,0x65,0x14,0xEC,0x06,0x01,0x95,0x31,0x8F,0xD4,0x3B,0xE9,0xB8,0xF0,0xCC,0x66,0x9E,0x3F,0x84,0x40,0x57,0xCB,0xDD,0xF8,0xBD,0xA1,0x91,0xBB,0x64,0x47,0x3B,0xC8,0xDC,0x9A,0x73,0x0D,0xB8,0xF6,0xB4,0xED,0xE3,0x92,0x41,0x86,0xFF,0xD9,0xB8,0xC7,0x73,0x57,0x89,0xC2,0x3A,0x36,0xBA,0x0B,0x8A,0xF6,0x53,0x72,0xEB,0x57,0xEA,0x5D,0x89,0xE7,0xD1,0x4E,0x9C,0x7B,0x6B,0x55,0x74,0x60,0xF1,0x08,0x85,0xDA,0x16,0xAC,0x92,0x3F,0x15,0xAF,0x37,0x58,0xF0,0xF0,0x3E,0xBD,0x3C,0x5C,0x2C,0x94,0x9C,0xBA,0x30,0x6D,0xB4,0x4E,0x6A,0x2C,0x07,0x6C,0x5F,0x67,0xE2,0x81,0xD7,0xEF,0x56,0x78,0x5D,0xC4,0xD7,0x59,0x45,0xE4,0x91,0xF0,0x19,0x18,0x80,0x0A,0x9E,0x2D,0xC6,0x6F,0x60,0x08,0x05,0x66,0xCE,0x0D,0xAF,0x8D,0x17,0xEA,0xD4,0x6A,0xD8,0xE3,0x0A,0x24,0x7C,0x9F};
   u8 pubexp_1408[]={0x03};
   u8 issuer_cert_1408[]={0x62,0xBC,0x5F,0x60,0xD2,0x7E,0x2C,0x61,0x16,0x03,0xC9,0x99,0xE0,0x0E,0xA0,0xB3,0x9F,0x01,0xDC,0xB4,0x01,0xB0,0xAD,0xA8,0xF5,0x45,0x4E,0x5B,0x43,0x3B,0x2F,0xE2,0xD6,0xB7,0xB0,0x55,0xF0,0x3D,0x27,0x14,0xEB,0x21,0x4D,0x5B,0x11,0xEB,0x4D,0x11,0x72,0x2D,0x69,0x04,0xA4,0x22,0x46,0x7F,0x35,0x08,0x78,0x42,0xBA,0x67,0xE6,0x0A,0xFF,0x09,0x39,0x4E,0x4A,0x2C,0xAC,0xB2,0xF7,0xC3,0xF2,0x1B,0x20,0x92,0xD1,0x93,0x28,0xE7,0x5C,0x49,0x9F,0xE0,0x5B,0xD1,0x63,0xF9,0x40,0xEC,0x8C,0xA8,0xAB,0xA3,0x81,0x45,0xE1,0xCD,0x58,0x8A,0xF2,0x84,0x27,0x6F,0x76,0xF4,0x0C,0x38,0x46,0x28,0x66,0x3D,0x4D,0xAB,0xB8,0xF5,0x47,0xEE,0x03,0x99,0xCD,0xF8,0xF9,0x10,0x9F,0x05,0xC6,0x44,0x7D,0x3C,0x3B,0xD1,0x01,0x67,0x3C,0xD5,0x15,0x42,0xB9,0xAC,0x8E,0x23,0x89,0x8D,0xA2,0xFE,0x6C,0xF2,0x89,0xB9,0x3C,0x24,0xC4,0xDB,0xD0,0xE7,0xAE,0xD9,0xA1,0x63,0x5A,0xAA,0x03,0xB5,0xC8,0x2C,0x9B,0x01,0x7B,0x91,0x80,0x73,0x03,0x66};

   u8 visa_puk_1984[]={0xAC,0xD2,0xB1,0x23,0x02,0xEE,0x64,0x4F,0x3F,0x83,0x5A,0xBD,0x1F,0xC7,0xA6,0xF6,0x2C,0xCE,0x48,0xFF,0xEC,0x62,0x2A,0xA8,0xEF,0x06,0x2B,0xEF,0x6F,0xB8,0xBA,0x8B,0xC6,0x8B,0xBF,0x6A,0xB5,0x87,0x0E,0xED,0x57,0x9B,0xC3,0x97,0x3E,0x12,0x13,0x03,0xD3,0x48,0x41,0xA7,0x96,0xD6,0xDC,0xBC,0x41,0xDB,0xF9,0xE5,0x2C,0x46,0x09,0x79,0x5C,0x0C,0xCF,0x7E,0xE8,0x6F,0xA1,0xD5,0xCB,0x04,0x10,0x71,0xED,0x2C,0x51,0xD2,0x20,0x2F,0x63,0xF1,0x15,0x6C,0x58,0xA9,0x2D,0x38,0xBC,0x60,0xBD,0xF4,0x24,0xE1,0x77,0x6E,0x2B,0xC9,0x64,0x80,0x78,0xA0,0x3B,0x36,0xFB,0x55,0x43,0x75,0xFC,0x53,0xD5,0x7C,0x73,0xF5,0x16,0x0E,0xA5,0x9F,0x3A,0xFC,0x53,0x98,0xEC,0x7B,0x67,0x75,0x8D,0x65,0xC9,0xBF,0xF7,0x82,0x8B,0x6B,0x82,0xD4,0xBE,0x12,0x4A,0x41,0x6A,0xB7,0x30,0x19,0x14,0x31,0x1E,0xA4,0x62,0xC1,0x9F,0x77,0x1F,0x31,0xB3,0xB5,0x73,0x36,0x00,0x0D,0xFF,0x73,0x2D,0x3B,0x83,0xDE,0x07,0x05,0x2D,0x73,0x03,0x54,0xD2,0x97,0xBE,0xC7,0x28,0x71,0xDC,0xCF,0x0E,0x19,0x3F,0x17,0x1A,0xBA,0x27,0xEE,0x46,0x4C,0x6A,0x97,0x69,0x09,0x43,0xD5,0x9B,0xDA,0xBB,0x2A,0x27,0xEB,0x71,0xCE,0xEB,0xDA,0xFA,0x11,0x76,0x04,0x64,0x78,0xFD,0x62,0xFE,0xC4,0x52,0xD5,0xCA,0x39,0x32,0x96,0x53,0x0A,0xA3,0xF4,0x19,0x27,0xAD,0xFE,0x43,0x4A,0x2D,0xF2,0xAE,0x30,0x54,0xF8,0x84,0x06,0x57,0xA2,0x6E,0x0F,0xC6,0x17};
   u8 pubexp_1984[]={0x03};
   u8 issuer_cert_1984[]={0x41,0x41,0x11,0x96,0x60,0xEF,0x1B,0xAD,0xB7,0x69,0x34,0x32,0x64,0x7F,0x42,0x1A,0x8B,0xC5,0xE2,0xC5,0xAF,0x6F,0x27,0xD1,0xEF,0xA7,0x10,0xA0,0xD4,0xEE,0x14,0x82,0xCE,0x3A,0xD0,0x1F,0x3C,0x53,0x76,0x51,0xE1,0x34,0xBB,0xAE,0xD4,0x1E,0x23,0xA8,0x52,0x09,0x50,0xDE,0x5E,0xF6,0xC7,0xB7,0xCA,0xBC,0xC9,0x87,0x8B,0x46,0x10,0xB8,0xFC,0x95,0x02,0x44,0x40,0x52,0x17,0xEC,0x48,0x35,0x12,0xB3,0x35,0x7E,0x52,0x89,0xF9,0xAD,0x6C,0x5B,0x32,0xFC,0x36,0x61,0x9F,0x74,0xB6,0x1D,0x54,0x6B,0x73,0xE4,0x1B,0x69,0x51,0x04,0xB5,0xC2,0x46,0xE2,0x00,0xA0,0xBD,0x42,0x05,0x94,0x44,0x08,0xC2,0xC8,0x52,0x87,0x05,0x80,0x97,0x65,0xF3,0x3B,0x50,0x7C,0x41,0x1E,0x3A,0xA3,0xD6,0xFA,0x9F,0xBA,0x97,0x1B,0x91,0x14,0xB9,0x35,0x50,0xB9,0x8A,0x11,0x3C,0x93,0x06,0x7B,0x0D,0x6F,0xA6,0x9D,0xEB,0x92,0x8A,0x0D,0x8D,0x5D,0x95,0xE4,0x9B,0x64,0x8D,0xCA,0x20,0x61,0xAB,0x24,0xD1,0x77,0x37,0xDF,0x5A,0x9A,0x66,0xF5,0x3E,0xF3,0xDA,0xF4,0xE0,0xEE,0xC5,0xA7,0x0D,0xD5,0xA2,0x5D,0x4A,0x70,0x45,0xC9,0x0A,0x55,0x32,0x84,0x69,0x4F,0x78,0xCF,0xEC,0x1D,0xA8,0x11,0x1E,0xB9,0xD9,0x6F,0xC9,0xBB,0xDE,0xCF,0xAD,0x40,0xB6,0x18,0xD9,0x9D,0x73,0xD3,0x4E,0xC1,0x91,0x0D,0xD1,0xF5,0xE2,0x98,0xEB,0x44,0xF4,0x25,0x82,0x07,0xE6,0x9E,0xCE,0xA7,0xFA,0x54,0x8A,0x68,0x56,0x74,0x12,0xB0,0xF2,0x27,0x8F,0x3A};
   u32 modulus32[64];
   u32 pubexp32[64];
   u32 message32[64];
   u32 result32[64];
   u8 result[256];
   int i;
   PRINTF("EMV ADVT ");
   PRINTF("visa: %d, issuer: %d\n",sizeof(visa_puk_1152),sizeof(issuer_cert_1152));
   ucl_data_os2int(modulus32,sizeof(visa_puk_1152)/4,visa_puk_1152,sizeof(visa_puk_1152));
   ucl_data_os2int(message32,sizeof(visa_puk_1152)/4,issuer_cert_1152,sizeof(issuer_cert_1152));
   ucl_data_os2int(pubexp32,1,pubexp_1152,sizeof(pubexp_1152));
   PRINTF("size=%d\n",sizeof(visa_puk_1152)/4);
   err=ucl_rsa_encryptBlock(result32,message32,pubexp32, 1,modulus32, sizeof(visa_puk_1152)/4);
   if(UCL_OK!=err)
     {
       PRINTF("err=%d\n",err);
       return(UCL_ERROR);
     }
   else
     PRINTF("OK\n");
   PRINTF("ADVT\n");
   ucl_data_int2os(result,sizeof(visa_puk_1152),result32,sizeof(visa_puk_1152)/4);
   for(i=0;i<(int)sizeof(visa_puk_1152);i++)
     PRINTF("%02x",result[i]);
   PRINTF("\n");
   if(result[0]!=0x6A)
     {
       PRINTF("ERROR on 1152\n");
       return(UCL_ERROR);
     }
   PRINTF("visa: %d, issuer: %d\n",sizeof(visa_puk_1408),sizeof(issuer_cert_1408));
   ucl_data_os2int(modulus32,sizeof(visa_puk_1408)/4,visa_puk_1408,sizeof(visa_puk_1408));
   ucl_data_os2int(message32,sizeof(visa_puk_1408)/4,issuer_cert_1408,sizeof(issuer_cert_1408));
   ucl_data_os2int(pubexp32,1,pubexp_1408,sizeof(pubexp_1408));
   err=ucl_rsa_encryptBlock(result32,message32,pubexp32, 1,modulus32, sizeof(visa_puk_1408)/4);
   if(UCL_OK!=err)
     {
       PRINTF("err=%d\n",err);
       return(UCL_ERROR);
     }
   ucl_data_int2os(result,sizeof(visa_puk_1408),result32,sizeof(visa_puk_1408)/4);
   for(i=0;i<(int)sizeof(visa_puk_1408);i++)
     PRINTF("%02x",result[i]);
   PRINTF("\n");
   if(result[0]!=0x6A)
     {
       PRINTF("ERROR on 1408\n");
       return(UCL_ERROR);
     }
   PRINTF("visa: %d, issuer: %d\n",sizeof(visa_puk_1984),sizeof(issuer_cert_1984));
   ucl_data_os2int(modulus32,sizeof(visa_puk_1984)/4,visa_puk_1984,sizeof(visa_puk_1984));
   ucl_data_os2int(message32,sizeof(visa_puk_1984)/4,issuer_cert_1984,sizeof(issuer_cert_1984));
   ucl_data_os2int(pubexp32,1,pubexp_1984,sizeof(pubexp_1984));
   err=ucl_rsa_encryptBlock(result32,message32,pubexp32, 1,modulus32, sizeof(visa_puk_1984)/4);
   if(UCL_OK!=err)
     {
       PRINTF("err=%d\n",err);
       return(UCL_ERROR);
     }
   ucl_data_int2os(result,sizeof(visa_puk_1984),result32,sizeof(visa_puk_1984)/4);
   for(i=0;i<(int)sizeof(visa_puk_1984);i++)
     PRINTF("%02x",result[i]);
   PRINTF("\n");
   if(result[0]!=0x6A)
     {
       PRINTF("ERROR on 1984\n");
       return(UCL_ERROR);
     }
   PRINTF("OK\n");
   return(UCL_OK);
 }

int ucl_quick_keygen(int maxloop)
{
  u32 *p,*q,*d;
  u32 *dp,*dq,*qinv;
  u32 v[UCL_RSA_KEY_MAXPRE], s[UCL_RSA_KEY_MAXPRE];
  u32 msg[UCL_RSA_KEY_MAXPRE];
  u32 n[UCL_RSA_KEY_MAXPRE];
  int imsg;
  int msgmax=1;
  int err;
  int thesize,thesizemax,miniloop;
  int i;
  int resu;
  //thesize=64;//2048bits
  //thesize=96; //3072 bits
  thesizemax=128;

  if (ucl_stack_alloc(&p, thesizemax/2) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&q, thesizemax/2) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&d, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&dp, thesizemax/2) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&dq, thesizemax/2) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&qinv, thesizemax/2) != UCL_OK)
    return UCL_STACK_ERROR;
    for(i=0;i<thesizemax;i++)
      n[i]=v[i]=s[i]=msg[i]=0;

  for(thesize=64;thesize<=thesizemax;thesize+=32)
    {
      PRINTF("RSA-%d keygen (%d gen., %d verif./gen.)\n",thesize*32,maxloop,msgmax);
	{
	  for(miniloop=0;miniloop<maxloop;miniloop++)
	    {
	      PRINTF(".%d\n",miniloop);
	      // generate rsa keypair, with F4=65537
		err=ucl_rsa_param_gen(n,p,q,d,(u32 *)_e2048_,1,thesize);
	      if(err!=UCL_OK)
		{
		  PRINTF("ERROR RSA %d %d GEN\n",err,thesize*32);
		  resu=UCL_ERROR;
		  goto endofroutine;
		}
	      else
		PRINTF("generated\n");
	      //generate msgmax messages
	      //and test encrypt-decrypt cycle with the generated RSA key
	      for(imsg=0;imsg<msgmax;imsg++)
		{
		  PRINTF("<%d>\n",imsg);
		  ucl_rng_read((u8*)msg,thesize*4,UCL_RAND_DEFAULT);
		  msg[thesize-1]=0;
		  err=ucl_rsa_encryptBlock(v,(u32 *)msg,(u32 *)_e2048_,1,n,thesize);
		  if(err!=UCL_OK)
		    {
		      PRINTF("ERROR RSA %d ENC (%d)\n",thesize*32,err);
		      resu=UCL_ERROR;
		      goto endofroutine;
		    }
		  err=ucl_rsa_decryptBlock (s,v,d,n,thesize);
		  if(err!=UCL_OK)
		    {
		      PRINTF("ERROR RSA %d RET (%d)\n",thesize*32,err);
		      resu=UCL_ERROR;
		      goto endofroutine;
		    }
		  if(memcmp(s,msg,thesize)!=0)
		    {
		      PRINTF("ERROR RSA DEC %d\n",thesize*32);
		      resu=UCL_ERROR;
		      goto endofroutine;
		    }
		}
	      PRINTF("checked\n");
	    }
	}
      PRINTF("RSA-%d CRT keygen (%d gen., %d verif./gen.)\n",thesize*32,maxloop,msgmax);
      for(miniloop=0;miniloop<maxloop;miniloop++)
	{
	  PRINTF(".%d\n",miniloop);
	  // generate rsa keypair, with F4=65537
	  err=ucl_rsa_crt_param_gen(n,d,p,q,dp,dq,qinv,(u32*)_e2048_,1,thesize);
	  if(err!=UCL_OK)
	    {
	      PRINTF("ERROR RSA %d %d GEN\n",err,thesize*32);
	      resu=UCL_ERROR;
	      goto endofroutine;
	    }
	  else
	    PRINTF("generated\n");
	  err=ucl_rsa_crt_parameters(n, d, dp, dq, qinv, p, q,(u32*) _e2048_, 1, thesize);
	  //generate msgmax messages
	  //and test encrypt-decrypt cycle with the generated RSA key
	  for(imsg=0;imsg<msgmax;imsg++)
	    {
	      PRINTF("<%d>\n",imsg);
	      ucl_rng_read((u8*)msg,thesize*4,UCL_RAND_DEFAULT);
	      msg[thesize-1]=0;
	      PRINTF("ENC\n");
	      err=ucl_rsa_encryptBlock(v,msg,(u32*)_e2048_,1,n,thesize);
	      if(err!=UCL_OK)
		{
		  PRINTF("ERROR RSA err %d %d ENC\n",err,thesize*32);
		  resu=UCL_ERROR;
		  goto endofroutine;
		}
	      if(96>thesize)
		{
		  err=ucl_rsa_decryptBlock (s,v,d,n,thesize);
		  if(err!=UCL_OK)
		    {
		      PRINTF("ERROR RSA %d %d RET\n",err,thesize*32);
		      resu=UCL_ERROR;
		      goto endofroutine;
		    }
		  if(memcmp(s,msg,thesize)!=0)
		    {
		      PRINTF("ERROR RSA DEC %d\n",thesize*32);
		      resu=UCL_ERROR;
		      goto endofroutine;
		    }
		}
	      err=ucl_rsa_crt_decryptBlock (s,v,dp,dq,p,q,qinv,(u32*)_e2048_,1,n,thesize);
	      if(err!=UCL_OK)
		{
		  PRINTF("ERR %d\n",err);
		  resu=UCL_ERROR;
		  goto endofroutine;
		}
	      if(memcmp(s,msg,thesize)!=0)
		{
		  resu=UCL_ERROR;
		  goto endofroutine;
		}
	      PRINTF("DEC-CRT-NOCM\n");
	      err=ucl_rsa_crt_decryptBlock_without_protection(s,v,dp,dq,p,q,qinv,(u32*)_e2048_,1,n,thesize);
	      if(err!=UCL_OK)
		{
		  resu=UCL_ERROR;
		  goto endofroutine;
		}
	      else
		PRINTF("wo prot OK\n");
	      if(memcmp(s,msg,thesize)!=0)
		{
		  resu=UCL_ERROR;
		  goto endofroutine;
		}
	    }
	  PRINTF("checked\n");
	}
    }
  resu=UCL_OK;
 endofroutine:
  if (ucl_stack_free(&qinv) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_free(&dq) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_free(&dp) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_free(&d) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_free(&q) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_free(&p) != UCL_OK)
    return UCL_STACK_ERROR;
PRINTF("\n");
 return(resu);
}


int ucl_quick_keygen_fips186_4(int maxloop)
{
  u32 *v,*s,*n,*p,*q,*d,*msg;
  u32 *dp,*dq,*qinv;
  int imsg;
  int msgmax=2;
  int err;
  int thesize,miniloop,thesizemax;
  int ret;
  
  //thesize=64;//2048bits
  //thesize=96; //3072 bits
  thesizemax=128;

  if (ucl_stack_alloc(&v, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&s, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&n, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&p, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&q, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&d, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&dp, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&dq, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&qinv, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&msg, thesizemax) != UCL_OK)
    return UCL_STACK_ERROR;
  
  ret=UCL_OK;
  for(thesize=32;thesize<=thesizemax;thesize+=32)
    {
      PRINTF("FIPS RSA-%d keygen (%d gen., %d verif./gen.)\n",thesize*32,maxloop,msgmax);
      for(miniloop=0;miniloop<maxloop;miniloop++)
	{
	  PRINTF(".%d\n",miniloop);
	  // generate rsa keypair, with F4=65537
	  err=ucl_rsa_param_gen_fips186_4(n,p,q,d,(u32 *)_e2048_,1,thesize);
	  if(err!=UCL_OK)
	    {
	      PRINTF("ERROR RSA %d GEN (%d)\n",thesize*32,err);
	      ret=UCL_ERROR;
	      goto endofipsroutine;
	    }
	  else
	    {
	      PRINTF("generated\n");
	      //generate msgmax messages
	      //and test encrypt-decrypt cycle with the generated RSA key
	      for(imsg=0;imsg<msgmax;imsg++)
		{
		  ucl_rng_read((u8*)msg,thesize*4,UCL_RAND_DEFAULT);
		  //normalize the message
		  msg[thesize-1]=0;
		  err=ucl_rsa_encryptBlock(v,(u32 *)msg,(u32 *)_e2048_,1,n,thesize);
		  if(err!=UCL_OK)
		    {
		      PRINTF("ERROR RSA %d ENC\n",thesize*32);
		      ret=UCL_ERROR;
		      goto endofipsroutine;
		    }
		  if(thesize<96)
		    {
		      err=ucl_rsa_decryptBlock (s,v,d,n,thesize);
		      if(err!=UCL_OK)
			{
			  PRINTF("ERROR RSA %d RET\n",thesize*32);
			  ret=UCL_ERROR;
			  goto endofipsroutine;
			}
		      if(memcmp(s,msg,thesize)!=0)
			{
			  PRINTF("ERROR RSA DEC %d\n",thesize*32);
			  ret=UCL_ERROR;
			  goto endofipsroutine;
			}
		    }
		}
	      PRINTF("checked\n");
	    }
	}

      PRINTF("FIPS RSA-%d CRT keygen (%d gen., %d verif./gen.)\n",thesize*32,maxloop,msgmax);
      for(miniloop=0;miniloop<maxloop;miniloop++)
	{
	  PRINTF(".%d\n",miniloop);
	  // generate rsa keypair, with F4=65537
	  err=ucl_rsa_crt_param_gen_fips186_4(n,d,p,q,dp,dq,qinv,(u32*)_e2048_,1,thesize);
	  if(err!=UCL_OK)
	    {
	      PRINTF("ERROR RSA %d %d GEN\n",err,thesize*32);
	      ret=UCL_ERROR;
	      goto endofipsroutine;
	    }
	  else
	    {
	      PRINTF("generated\n");
	      err=ucl_rsa_crt_parameters(n, d, dp, dq, qinv, p, q,(u32*) _e2048_, 1, thesize);
	      //generate msgmax messages
	      //and test encrypt-decrypt cycle with the generated RSA key
	      for(imsg=0;imsg<msgmax;imsg++)
		{
		  ucl_rng_read((u8*)msg,thesize*4,UCL_RAND_DEFAULT);
		  //normalize the message
		  msg[thesize-1]=0;
		  err=ucl_rsa_encryptBlock(v,msg,(u32*)_e2048_,1,n,thesize);
		  if(err!=UCL_OK)
		    {
		      PRINTF("ERROR RSA %d ENC\n",thesize*32);
		      ret=UCL_ERROR;
		      goto endofipsroutine;
		    }
		  if(96>thesize)
		    {
		      err=ucl_rsa_decryptBlock (s,v,d,n,thesize);
		      if(err!=UCL_OK)
			{
			  PRINTF("ERROR RSA %d RET\n",thesize*32);
			  ret=UCL_ERROR;
			  goto endofipsroutine;
			}
		      if(memcmp(s,msg,thesize)!=0)
			{
			  PRINTF("ERROR RSA DEC %d\n",thesize*32);
			  ret=UCL_ERROR;
			  goto endofipsroutine;
			}
		    }
		  err=ucl_rsa_crt_decryptBlock (s,v,dp,dq,p,q,qinv,(u32*)_e2048_,1,n,thesize);
		  if(err!=UCL_OK)
		    {
		      PRINTF("ERROR RSA-CRT %d RET\n",thesize*32);
		      ret=UCL_ERROR;
		      goto endofipsroutine;
		    }
		  if(memcmp(s,msg,thesize)!=0)
		    {
		      PRINTF("ERROR RSA-CRT DEC %d\n",thesize*32);
		      ret=UCL_ERROR;
		      goto endofipsroutine;
		    }
		}
	      PRINTF("checked\n");
	    }
	}
    }

 endofipsroutine:
    if (ucl_stack_free(&msg) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&qinv) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&dq) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&dp) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&d) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&q) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&p) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&n) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&s) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&v) != UCL_OK)
        return UCL_STACK_ERROR;
 return(ret);
}


int test_rsa_fips_kat_b33(void)
{
  u8 e[] = {0x00, 0x37, 0xa7, 0xf1};
  u32 e_rev[sizeof(e)/4];
  u8 p[] = {0xb5, 0x9f, 0x51, 0xf0, 0x35, 0x98, 0xfb, 0x37, 0xfc,
	    0x23, 0xc4, 0xe4, 0x67, 0xbb, 0x4e, 0x45, 0x33, 0xcc, 0x85, 0x64, 0xa5,
	    0xc6, 0x2b, 0xbd, 0x28, 0xd0, 0xd8, 0x32, 0x8e, 0xba, 0x56, 0xae, 0xae,
	    0xe4, 0x58, 0xba, 0x56, 0x50, 0x52, 0xaa, 0xdb, 0x6d, 0x83, 0xa8, 0x38,
	    0x04, 0xea, 0xeb, 0x67, 0x9a, 0xfa, 0xf7, 0x30, 0xc4, 0xb3, 0x94, 0x0f,
	    0x31, 0x2e, 0x4c, 0x7c, 0xf6, 0x19, 0xc2, 0x1d, 0x3d, 0xe1, 0x4e, 0x06,
	    0xdc, 0x77, 0x15, 0x6e, 0x8e, 0xd5, 0xdc, 0x5b, 0x07, 0x55, 0xec, 0xc1,
	    0x18, 0xef, 0xcf, 0x3c, 0x88, 0xa9, 0xd5, 0xc5, 0x9f, 0x76, 0x8f, 0x75,
	    0x32, 0x19, 0x36, 0x95, 0x16, 0x23, 0x69, 0xd5, 0x3b, 0x3d, 0x20, 0x43,
	    0x9e, 0x2b, 0x72, 0xe5, 0x4b, 0x56, 0x9a, 0x0d, 0x61, 0x87, 0x26, 0x32,
	    0xf0, 0xb7, 0x4c, 0x01, 0x76, 0x64, 0x58, 0xae, 0x6a, 0xe8, 0x9d};
  u32 p_rev[sizeof(p)/4];
  u8 q[] = {0xe7, 0xda, 0xdc, 0x84, 0xae, 0x66, 0x89, 0xda, 0xb6,
	    0x2e, 0x5c, 0x1a, 0xcc, 0xc7, 0x98, 0x64, 0xa9, 0x00, 0x06, 0xf5, 0x30,
	    0x2d, 0x72, 0x01, 0xa5, 0x70, 0x8f, 0x2e, 0x08, 0x35, 0xf0, 0x9d, 0x18,
	    0xb8, 0x00, 0x58, 0x54, 0xac, 0xd9, 0xb8, 0x33, 0x7d, 0xc2, 0xe8, 0x75,
	    0x2f, 0xc8, 0x08, 0xf4, 0xea, 0x89, 0x86, 0xc7, 0x0a, 0x44, 0x84, 0x42,
	    0xd3, 0xe3, 0xc8, 0x39, 0x3a, 0x36, 0xd2, 0xee, 0x31, 0xc3, 0xb2, 0x4d,
	    0x1b, 0x1c, 0x04, 0x3d, 0x71, 0xf6, 0x0a, 0xb2, 0x3b, 0x45, 0xf4, 0xd1,
	    0xc3, 0xae, 0x25, 0xf7, 0x3e, 0xc1, 0x87, 0x84, 0xa9, 0xa5, 0xa1, 0x6e,
	    0x04, 0x74, 0xaf, 0xb8, 0x9a, 0x3e, 0xba, 0x39, 0xc1, 0x5f, 0x93, 0x43,
	    0xb2, 0x21, 0x3e, 0x4b, 0x3d, 0x9f, 0x9e, 0x4a, 0x3d, 0x5a, 0x57, 0x70,
	    0x6e, 0x52, 0xdd, 0xef, 0xc2, 0x2e, 0x47, 0xe1, 0xa5, 0x13, 0x2b};
  u32 q_rev[sizeof(q)/4];
  
  if ( ucl_data_os2int(e_rev, sizeof(e_rev)/4, e, sizeof(e)) != UCL_OK) return 1;
  if ( ucl_data_os2int(p_rev, sizeof(p_rev)/4, p, sizeof(p)) != UCL_OK) return 1;
  if ( ucl_data_os2int(q_rev, sizeof(q_rev)/4, q, sizeof(q)) != UCL_OK) return 1;
  
  int res = ucl_fips186_4_kat_B33(p_rev, q_rev, (u32 *)e, sizeof(p_rev)/4);
  if (res == UCL_OK)
    {
      PRINTF("Result = P\n");
    } 
  else 
    {
      PRINTF("Result = %d\n", res);
      if (res < 0)
	{
	  PRINTF("Encountered unexpected error from ucl_fips186_4_kat_B33(): %d\n", res);
	  return(UCL_ERROR);
	}
    }
  return(UCL_OK);
}


int test_rsa(int maxloop)
{
  u32 *v,*d,*msg;

  int err;
  int i,j;
  int modulus_len;

  PRINTF("RSA testing----------\n");
  if(UCL_OK!=test_rsa_fips_kat_b33())
    {
      PRINTF("ERROR RSA FIPS KAT B33\n");
    }
  test_openssl_key_use();

  ucl_quick_keygen(1);
  ucl_quick_keygen_fips186_4(1);
  err=test_emv_advt();
  if(UCL_OK!=err)
    {
      PRINTF("ERROR EMV ADVT\n");
      return(UCL_ERROR);
    }
  PRINTF("RSA-ENC-1024 testing (%d)...\n",maxloop);
  modulus_len=32;
  if (ucl_stack_alloc(&v, modulus_len) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&d, modulus_len) != UCL_OK)
    return UCL_STACK_ERROR;
  if (ucl_stack_alloc(&msg, modulus_len) != UCL_OK)
    return UCL_STACK_ERROR;

  for(i=0;i<maxloop;i++)
    {
      if((i%1000)==0)
	PRINTF("#%d\n",i);
      err=ucl_rsa_encryptBlock(v,(u32*)_m_,(u32*) _e_, 1, (u32*)_n_, modulus_len);
      if(err!=UCL_OK)
	{
	  PRINTF("ERROR RSA-1024 %d ENC\n",err);
	  return(UCL_ERROR);
	}
      // check encryption result
      if( memcmp(v, _c_, modulus_len ) != 0 )
	{
	  PRINTF("ERROR..\n");
	  return(UCL_ERROR);
	  }
    }
  PRINTF("RSA ENC END--\n");
  PRINTF("RSA-DEC-1024 testing (%d)...\n",maxloop);
  for(i=0;i<maxloop;i++)
    {
      if((i%100)==0)
	PRINTF("iteration #%d\n",i);
      err=ucl_rsa_decryptBlock(v,(u32*)_c_, (u32*)_d_, (u32*)_n_, modulus_len);
      if(err!=UCL_OK)
	{
	  PRINTF("ERROR RSA %d %d DEC\n",err,modulus_len*32);
	  return(UCL_ERROR);
	}
      // check encryption result
            if( memcmp(v, _m_, modulus_len ) != 0 )
	{
	  PRINTF("ERROR..\n");
	  return(UCL_ERROR);
	}
    }
  PRINTF("RSA DEC END--\n");

  PRINTF("RSA-CRT %d (%d)\n",modulus_len*32,maxloop);
  for(i=0;i<maxloop;i++)
    {
      if((i%100)==0)
	PRINTF("iteration #%d\n",i);
      err=ucl_rsa_crt_decryptBlock(v, (u32 *)_c_, (u32 *)_dp_, (u32 *)_dq_, (u32 *)_p_, (u32 *)_q_, (u32 *)_qInv_, (u32 *)_e_, 1, (u32 *)_n_, modulus_len);
      if(err!=UCL_OK)
	{
	  PRINTF("ERROR RSA %d CRT (err=%d)\n",modulus_len*32,err);
	  return(UCL_ERROR);
	}
      // compare with origin message
      if( memcmp(v, _m_, modulus_len ) != 0 )
	{
	  PRINTF("DIFFERENCE\n");
	  for(j=0;j<modulus_len;j++)
	    PRINTF("%08x",v[j]);
	  PRINTF("\n");
	  for(j=0;j<modulus_len;j++)
	    PRINTF("%08x",_m_[j]);
	  PRINTF("\n");
	  return(UCL_ERROR);
	  }
    }
  PRINTF("RSA-CRT DEC END--\n");
    if (ucl_stack_free(&msg) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&d) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&v) != UCL_OK)
        return UCL_STACK_ERROR;

  //rsa 2048
  modulus_len=64;
    if (ucl_stack_alloc(&v, modulus_len) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_alloc(&d, modulus_len) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_alloc(&msg, modulus_len) != UCL_OK)
        return UCL_STACK_ERROR;
  PRINTF("RSA-ENC-2048 testing (%d)...\n",maxloop);
  for(i=0;i<maxloop;i++)
    {
      if((i%100)==0)
	PRINTF("#%d\n",i);
      err=ucl_rsa_encryptBlock(v,(u32*)_m2048_,(u32*) _e2048_, 1,(u32*) _n2048_, modulus_len);
      if(err!=UCL_OK)
	{
	  PRINTF("ERROR RSA %d ENC\n",err);
	  break;
	  //	  return(UCL_ERROR);
	}
      // check encryption result
      if( memcmp(v, _c2048_, modulus_len ) != 0 )
	    {
	      PRINTF("ERROR..\n");
	      return(UCL_ERROR);
	    }
    }
  PRINTF("RSA-DEC-2048 testing (%d)...\n",maxloop);
  for(i=0;i<maxloop;i++)
    {
      if((i%100)==0)
	PRINTF("iteration #%d\n",i);
      err=ucl_rsa_decryptBlock(v,(u32*)_c2048_,(u32*) _d2048_,(u32*) _n2048_, modulus_len);
      if(err!=UCL_OK)
	{
	  PRINTF("ERROR RSA %d %d DEC\n",err,modulus_len*32);
	  return(UCL_ERROR);
	}
      // check encryption result
      if( memcmp(v, _m2048_, modulus_len ) != 0 )
	{
	  PRINTF("ERROR..\n");
	  return(UCL_ERROR);
	  }
    }
  PRINTF("END\n");

  PRINTF("RSA-DEC-CRT-2048 testing (%d)...\n",maxloop);
  for(i=0;i<maxloop;i++)
    {
      if((i%100)==0)
	PRINTF("iteration #%d\n",i);
      err=ucl_rsa_crt_decryptBlock(v, (u32 *)resu2048, (u32 *)dp2048, (u32 *)dq2048, (u32 *)p2048, (u32 *)q2048, (u32 *)qinv2048, (u32 *)_e2048_, 1, (u32 *)modulus2048, modulus_len);
      if(err!=UCL_OK)
	{
	  PRINTF("ERROR RSA %d CRT (err=%d)\n",modulus_len*32,err);
	  return(UCL_ERROR);
	}
      // compare with origin message
      if( memcmp(v, m2048, 32 ) != 0 )
	{
	  PRINTF("DIFFERENCE\n");
	  for(j=0;j<modulus_len;j++)
	    PRINTF("%08x",v[j]);
	  PRINTF("\n");
	  for(j=0;j<modulus_len;j++)
	    PRINTF("%08x",m2048[j]);
	  PRINTF("\n");
	  return(UCL_ERROR);
	  }
    }
  PRINTF("END\n");  
    if (ucl_stack_free(&msg) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&d) != UCL_OK)
        return UCL_STACK_ERROR;
    if (ucl_stack_free(&v) != UCL_OK)
        return UCL_STACK_ERROR;

  return(UCL_OK);
}
  u32 dp_crt[UCL_RSA_KEY_MAXSIZE/8],dq_crt[UCL_RSA_KEY_MAXSIZE/8],qinv_crt[UCL_RSA_KEY_MAXSIZE/8];
  u32 n[UCL_RSA_KEY_MAXSIZE/4],p[UCL_RSA_KEY_MAXSIZE/8],q[UCL_RSA_KEY_MAXSIZE/8],d[UCL_RSA_KEY_MAXSIZE/4],dbis[UCL_RSA_KEY_MAXSIZE/4];
  u32 n_crt[UCL_RSA_KEY_MAXSIZE/4];
  u32 v[UCL_RSA_KEY_MAXSIZE/4], s[UCL_RSA_KEY_MAXSIZE/4];
int test_rsa_crt_parameters(int maxloop)
{
  int err;
  int miniloop;
  u32 msg[UCL_RSA_KEY_MAXSIZE/4];
  int i,imsg;
  int thesize;
  u32  e[1] = {0x10001} ;
  // parse all sizes from 1024 bits to max authorized
  PRINTF("RSA CRT parameters test\n");
  for(miniloop=32;miniloop<=UCL_RSA_KEY_MAXSIZE/8;miniloop+=32)
    {
      thesize=miniloop;
      PRINTF(".%d ",thesize*32);
      PRINTF("rsa gen\n");
      err=ucl_rsa_param_gen(n,p,q,d,e,1,thesize);
      PRINTF("rsa crt params\n");
      err=ucl_rsa_crt_parameters(n_crt, dbis, dp_crt, dq_crt, qinv_crt, p, q, e, 1, thesize);
      if(err!=UCL_OK)
	{
	  PRINTF("ERROR RSA %d %d CRT parameters conversion\n",err,thesize*32);
	  return(err);
	}
      if(memcmp(dbis,d,thesize)!=0)
	{
	  PRINTF("ERROR d and dbis different\n");
	  return(UCL_ERROR);
	}
      if(memcmp(n_crt,n,thesize)!=0)
	{
	  PRINTF("ERROR n and n_crt different\n");
	  return(UCL_ERROR);
	}
      //encrypt and decrypt to check validity of parameters
      for(imsg=0;imsg<maxloop;imsg++)
	{
	  ucl_rng_read((u8*)msg,sizeof(msg),UCL_RAND_DEFAULT);
	  i=thesize-1;
	  while(i>0 && n[i]==0)
	    {
	      msg[i]=0;
	      i--;
	    }   
	  msg[i]=n[i]-1;
	  err=ucl_rsa_encryptBlock(v,(u32 *)msg,(u32 *)e,1,n,thesize);
	  if(err!=UCL_OK)
	    {
	      PRINTF("ERROR RSA %d CRT ENC\n",thesize*32);
	    }
	  err=ucl_rsa_crt_decryptBlock (s,v,dp_crt,dq_crt,p,q,qinv_crt,(u32*)e,1,n,thesize);
	  if(err!=UCL_OK)
	    {
	      PRINTF("ERROR RSA %d CRT DEC\n",thesize*32);
	    }
	  if(memcmp(s,msg,thesize)!=0)
	    {
	      PRINTF("ERROR RSA %d CRT CMP GEN\n",thesize*32);
	    }
	}
    }
  PRINTF("--END\n");
  return(UCL_OK);
}

#endif//RSA
